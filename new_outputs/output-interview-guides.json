{
  "team_id": "aline123",
  "items": [
    {
      "team_id": "",
      "items": [
        {
          "title": "It's OK to postpone your interviews if you're not ready",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryBlog HomeIt's OK to postpone your interviews if you're not readyBy Aline Lerner | Published: March 25, 2025; Last updated: April 28, 2025At interviewing.io, we’ve seen hundreds of thousands of engineers go through job searches, and the biggest mistakes we see people make are all variations on the same theme: not postponing their interview when they aren’t ready. I’ve found myself repeating that it’s OK to postpone interviews so often that I finally broke down and decided to make it a blog post. It’s very simple advice, so the bulk of this post will be spent trying to convince you that it’s fine to postpone. And then of course I’ll tell you what to say. Do any of these situations sound familiar? A recruiter from a FAANG (or other top-tier) company contacts you out of the blue and invites you to interview. You do the recruiter call, and it goes well. The recruiter reaches out to schedule your technical phone screen. You haven’t practiced enough, and you know it, but you are scared to tell the recruiter that you want to postpone the interview by a few months (months?!) because the position may no longer be there. So, you plow ahead, do the phone screen, fail it, and then you’re frozen out for a year. You were able to postpone your technical phone screen and take the time to study up on data structures & algorithms problems. You do well in the interview. But then your recruiter schedules your onsite the following week. Because you were so focused on DS&A prep, you haven’t had much time to study up on system design. You fumble the system design interview during the onsite, and you either get rejected or get down-leveled. Both of these situations are extremely common, but they’re both preventable. You can just ask to postpone. There are a few edge cases where that’s not a good idea, but in most situations, it’s the right thing to do. When postponing is OK, and when you shouldn’t take our advice If you’re applying to a large company with a centralized process (in other words, a process where you interview first and get matched with a team later), postponing is almost always OK. These companies are perpetually hiring, and their open roles are evergreen.1 Even if you’re applying to a large company with a decentralized process (where you interview for a specific team), we recommend postponing unless you’re extremely excited about the team you’re talking to. In that scenario, it’s possible that if you postpone, the slot will be filled. But if it’s not a perfect fit and you’d be OK with another team, we recommend postponing — in the worst case, you’ll simply get slotted into a different team. The only time when postponing isn’t a good idea is when you’re applying to a very small company that has just one open headcount. In that scenario, it is possible that postponing will cost you the opportunity because they’ll choose another candidate. However, you can ask how likely that is to happen, up front. With that edge case out of the way, here’s a little-known fact about how timing works at large companies: Recruiters don’t really care when you interview. Though they’d prefer that you interview sooner rather than later so they can hit their numbers, at the end of the day, they’d rather be responsible for successful candidates than unsuccessful ones. Every recruiter, in every job search, will tell you that time is of the essence because of all the other candidates in the pipeline. Most of the time, that is irrelevant and just something they say to create an artificial sense of urgency. There are always other candidates in the pipeline because the roles are evergreen. But they have nothing to do with your prospects. Exactly what to say to postpone your interviews You can use this text verbatim when postponing your interviews, and, with some small edits, you can even use it several times (e.g., before the phone screen and then again before the onsite). I’m really excited about interviewing at \\[company name\\]. Unfortunately, if I’m honest, I haven’t had a chance to practice as much as I’d like. I know how hard and competitive these interviews are, and I want to put my best foot forward. I think I’ll realistically need a couple of months to prepare. How about we schedule my interview for \\[date\\]? One important thing to remember is to be conservative about how long it will take. You’ve probably heard the adage about how, when you have to estimate the time an engineering task will take, you should think of a number and double it. Here, you may even want to triple it. I’ve seen many candidates ask for 2 weeks because that feels like a reasonable thing to ask for, only to have it blow up in their face when they realize they need to ask for another extension (which is still worth doing but harder because the company may think you’re taking them for a ride). If you need two months, ask for two months. Postponing can also be a good way to control the timing of your job search This section is extra credit, but once you get comfortable with postponing your interviews when you’re not prepared, you can use the same skills to batch your interviews and ultimately control the timing of your job search. What does it mean to control the timing of your job search? Ideally, you want all of your offers to come in at the same time, both because it maximizes optionality (one company that arbitrarily offers first doesn’t rush you into making a decision) and maximizes leverage (you can negotiate from a position of power). If you want to dive deeper into this process, take a look at a book I recently co-wrote, Beyond Cracking the Coding Interview. It includes a full chapter about how to manage your job search, which covers everything from determining the order in which to approach companies to how to speed them up and slow them down once you’re in process. There’s a lot more detail than I can touch in this post, and much of it depends on your specific circumstances, but you can probably get 50% of the way there just by postponing your interviews in batches. The big insight here is that, except for the edge cases we discussed above, a recruiting process can be paused at any point. In other words, you can do a bunch of outreach to companies, then do a bunch of enthusiastic recruiter calls, and THEN pause all the processes until you’re prepared to do technical phone screens. Then, you batch the phone screens. Finally, if needed, you pause again to give yourself time to prepare for onsites. Onsite interviews require a different skill set than technical phone screens. The technical phone screen isn’t about depth or fit — it’s just a way to cut people who aren’t likely to pass the onsite. The onsite, on the other hand, isn’t just meant to cut poor performers. It’s at once a deeper dive into your technical ability and a way to gauge fit. If you’ll be interviewing with your future team (typical at companies with a decentralized process), it’s also meant to assess your ability to work together, collaborate on hard things, complement the team's existing skillset, and so on. It usually has some coding (to verify that your technical phone screen wasn’t a fluke), but the focus is usually on system design and behavioral interviews2, which are also the interviews commonly used for leveling decisions. So, onsite prep is much more about system design and getting your stories right for your behavioral interviews. Some people can pull off prepping for both coding and sys design/behavioral at the same time. For many, depending on their existing familiarity with the material, it’s a tall order. So, it’s wise to take the time you need and prepare. Then, once you’re ready, you batch the onsites. When your offers come in, you should ask for extensions as needed, speed companies up, and start negotiating (which we’ve written about in the past and which, of course, is covered at great depth in the book). Footnotes: Footnotes Yes, it’s true that in 2022, we saw several FAANGs and many other companies freeze hiring, and if you had postponed your interviews, you’d have been left out in the cold. Despite how devastating these freezes were to affected candidates (and to the tech economy as whole), they are extremely rare, and in our humble opinion, not worth optimizing for or worrying about. You are very unlikely to have to deal with an impending freeze. ↩ Some companies will also have technical deep dives, project presentations, assessments of niche skills, and so on. ↩ Life is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedRelated postsHow to get in the door at top companies: cold outreach to hiring managers. Part 2 of 2.How well do LeetCode ratings predict interview performance? Here's the data.I’ve conducted over 600 technical interviews on interviewing.io. Here are 5 common problem areas I’ve seen.We analyzed 100K technical interviews to see where the best performers work. Here are the results.Stuff we write aboutRecessionSalary negotiationCompany NewsData Deep DivesDiversityGuest PostsHiring is brokenInterview tipsFor employers, how to hire betterHave interviews coming up? Study up on common questions and topics.MEDIUMSystem DesignImage Filter ServiceCreate a service that allows users to upload an image and apply filters and then sends users a link to download their filtered image.MEDIUMData Structures and AlgorithmsK Closest Points To OriginGiven a list of tuples that represent (X, Y) coordinates on an XY plane and an integer K, return a list of the K-closest points to the origin (0, 0).HARDData Structures and AlgorithmsAlien DictionaryYou are given a list of lexicographically sorted words from an alien language. This language has a unique order. Return the alphabetical order of all the letters found in the list of words.BucketsQuestions & tipsPriority QueuesQuestions & tipsMapReduceQuestions & tipsStringsQuestions & tipsTriesQuestions & tipsRecursionQuestions & tipsWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/blog/its-ok-to-postpone-your-interviews-if-youre-not-ready",
          "author": "",
          "user_id": ""
        },
        {
          "title": "Read nine chapters of Beyond Cracking the Coding Interview for free",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryBlog HomeRead nine chapters of Beyond Cracking the Coding Interview for freeBy Aline Lerner | Published: March 2, 2025; Last updated: April 28, 2025Along with Gayle Laakmann McDowell, Mike Mroczka, and Nil Mamano, I wrote the official sequel to Cracking the Coding Interview. It's fittingly called Beyond Cracking the Coding Interview.. Now, we're releasing 9 chapters of the book for free! There are two PDFs in the linked folder: The first seven chapters of the book, covering topics such as why technical interviews are broken, what recruiters won't tell you, why not to spend a lot of time on resumes, and how to get in the door at companies without a referral. Two technical chapters: Sliding Windows and Binary Search. Our new take on Binary Search teaches one template that works for every binary search problem on LeetCode, with only a single-line change you need to remember. The Sliding Windows chapter features 6 unique sliding window templates that make off-by-one errors a thing of the past. Take a look, and let me know what you think. You can reach me at aline@interviewing.io.Life is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedRelated postsHow to sabotage your salary negotiations efforts before you even startHow hard is it to cheat in technical interviews with ChatGPT? We ran an experiment.Announcing our Pay Later Program: Don’t pay for mock interviews until you get a jobBuilding interviewing.io's collaborative & replayable whiteboard, or making systems design interviews not suckStuff we write aboutRecessionSalary negotiationCompany NewsData Deep DivesDiversityGuest PostsHiring is brokenInterview tipsFor employers, how to hire betterHave interviews coming up? Study up on common questions and topics.MEDIUMData Structures and AlgorithmsRight View Of Binary TreeGiven the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.HARDSystem DesignDesign WhatsAppDesign a message app system and client (e.g. WhatsApp) supporting a list of requirements.MEDIUMData Structures and AlgorithmsMaximum SubarrayGiven an integer array nums, find the subarray with the largest sum, and return its sum.TriesQuestions & tipsBinary SearchQuestions & tipsMatricesQuestions & tipsStringsQuestions & tipsQueuesQuestions & tipsStacksQuestions & tipsWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/blog/nine-free-chapters-of-beyond-cracking-the-coding-interview",
          "author": "",
          "user_id": ""
        },
        {
          "title": "How to get in the door at top companies: cold outreach to hiring managers. Part 2 of 2.",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryBlog HomeHow to get in the door at top companies: cold outreach to hiring managers. Part 2 of 2.By Aline Lerner | Published: July 31, 2024; Last updated: November 3, 2024In part 1 of this post, we talked about which channels are most effective for getting in the door and did an analysis of those channels along two axes: effectiveness and how much control you actually have. Here’s a quick summary. In the quadrant above, you can see that while getting contacted by an in-house recruiter is very effective, whether you get contacted or not is largely out of your hands. The channel that maximizes both effectiveness and control is cold outreach to hiring managers (not recruiters!) “done right”. What does “done right” mean? That’s what we’ll talk about in this post (part 2 of 2). Most people do this type of outreach incorrectly. Here, we’ll get very tactical and tell you exactly what to say and do to reach out to hiring managers at the companies you’re interested in and actually get responses. Here’s our recommended, hyper-practical approach. Prerequisites/tooling Buy a month or two of LinkedIn Sales Navigator. This will run you a few hundred dollars, but it’s worth it. Get an account with an email discovery tool like RocketReach (an excellent email discovery tool). Get Streak, which lets you do mail merges in Gmail. You create an email template, with variables for everything from recipient name to long snippets of personalized text, and then you upload a CSV with all the values. The resulting emails feel personalized but get sent to hundreds of people at once. Treat your job search like a sales funnel If you’re an engineer, chances are you haven’t ever done sales (maybe you had a job in high school selling Cutco knives or magazines, in which case what we’re about to say will resonate). But if you do sales for any appreciable amount of time, you’ll start thinking about everything in life as a funnel. Funnels are wide at the top and narrow at the bottom. That’s why they’re such an apt metaphor for the sales process — you do a lot of outreach, and you don’t get many responses. Of the responses you do get, relatively few will do the thing you want them to do. And even fewer will ultimately “close” (aka, buying — or, in this case, hiring). In your engineering career, you’ve intellectually mastered many abstract concepts that are much more complex than a funnel. Despite its simplicity, however, the funnel is one of the hardest concepts to internalize emotionally, especially for people who are used to having control over outcomes. When you write code for n hours, you can expect that you will build m features. In sales though, you do a lot of work, very little of it will pan out, and when it does pan out, it can feel almost random; an impersonal, mediocre email gets a response while your beautifully targeted email is met with deafening silence. And then there’s rejection. When you apply to jobs online and don’t hear back, it stings, but the sting is softened by the possibility that a human never even saw your application. You’re not reaching out to people when you apply online; you’re dealing with a bureaucratic machine. On the other hand, when you email a real human and they don’t respond, that hurts: you put yourself out there, someone made a value judgment about you, and you lost. The good news is that, after a while, the pain lessens, and you build up some useful emotional calluses and acquire the thousand-yard stare of someone who’s been rejected a million times for a million reasons, ranging from soul-crushingly legitimate to incontrovertibly random. Sadly, there’s no shortcut. You’ve got to do the reps, you’ve got to get the rejections, and you’ve got to pick yourself up again. You get used to it, and then it doesn’t hurt as much, because experience has taught you that if you keep going, you will eventually get to a yes. What to actually do First, come up with a target list of companies. How to do that is out of scope for this post, but we may write about it in the future. For now, we’ll assume you have a list. Once you have your list of companies, use LinkedIn Sales Navigator to find hiring managers at those companies (or founders or directors or VPs, as above). Below is an example query where we look for Google hiring managers. You might think that Google is so big that sifting through all their various hiring managers will be intractable. Fortunately, you can whittle down the list to a pretty manageable size by applying some filters. Here are our filters: Just targeting managers, not directors or VPs. Google is a huge organization. You want the people who are most likely to help, and they’re the ones who are struggling to hire for their teams. In position for less than 2 years: These are the people who are still trying to prove themselves and who are less likely to have a long-standing relationship with their recruiter to the point where they only rely on internal recruiting and overlook other sources of candidates. Geography: Let's focus on the places we most want to work. 1st- or 2nd-degree connection: This way, when they look you up, they’ll see some social proof. You can expand this to 3rd-degree connections, if needed. Once you have your list, put their LinkedIn URLs into a spreadsheet. Then, do a pass through your targets’ profiles and see if any of them link to personal websites, social media accounts, blogs, or anything else that will help you find common ground with them. Add any useful links in your spreadsheet because we’ll be mining them when we actually write our emails. Look up their email addresses Once you have your list of LinkedIn URLs, use a tool like RocketReach to look up their emails. Why not reach out on LinkedIn? While recruiters live on LinkedIn, managers generally do not. Possibly, they don't even like or check LinkedIn much. They live in their emails, so that's where you want to target them. RocketReach is a nice tool for email discovery because 1) it takes LinkedIn URLs as inputs and 2) its email database is generally up-to-date and correct.1 If RocketReach fails or you don't wish to pay for it, you might just be able to guess their email address, as email addresses tend to follow common forms: aline@interviewing.io (my actual email address), alerner@interviewing.io, or aline.lerner@interviewing.io. Where possible, contact managers via their work email address.2 In some cases, you won’t be able to find their work email, in which case it’s acceptable to fall back to their personal email. Write succinct, highly personalized emails Next, compose a fairly personalized, yet short, email. All too often, candidates write a long, generic cover letter that’s obviously been sent to a ton of people. I get many emails that look like this: Don’t do this! Don’t do this either! There is nothing here about why this candidate is a good fit for interviewing.io, and the bullets aren’t compelling enough on their own. Note that this particular email is from a marketer, not an engineer, but the anti-patterns are the same. Emails like the above are impersonal, but worst of all, they have a poor signal-to-noise ratio — I want to find a reason to say yes and to invest my valuable time into this person. But they’re not giving me one, and they’re making me work for it in the process. Don't open email with how they found you. This is a big pet peeve of ours. I don’t care how you found me! I know I’m on LinkedIn. What I care about is why talking to you will add value for me or why you’re interesting. Use the most significant real estate in the email, the first sentence, to tell me that! Don't be overly formal in how you address the person. Use their first name. Don't get their gender wrong (e.g., referring to a woman as \"sir\" — you’d be surprised how often this happens). Don't paste in a generic cover letter. These are sure to get ignored immediately — if you’re not going to put in the effort to write to me personally, why would I put in the effort to read your email? Don't forget to include a link to a LinkedIn or a personal website. We don’t recommend attaching your resume, though. It can seem overly formal/somewhat presumptuous if you're trying to build rapport. More broadly, if you want someone to go out on a limb for you, make it dead simple for them to justify expending their social/political capital on you. Hiring managers, as a rule, want to help. Make it a no-brainer for them. There are three components to a great cold email: Common ground with your target Proof that you’re worthy of their time A strong call to action Not every cold email will have (1) because you won’t always be able to find common ground with everyone — there’s simply not enough information out there about some targets to be able to craft a compelling narrative that’s highly personalized to them. But every cold email you write should have (2). It is your job to sell yourself quickly and succinctly. You want your target to feel like they’d be an idiot to pass up the chance to talk to you. Finding common ground The email below is personal, succinct, and finds common ground. Not only that, but it conveniently finds common ground that benefits the candidate (a soft-spot for non-traditional candidates, like himself!). To find common ground, reference something your target cares about. Then either show them that you care about it too or that helping you would fit into their worldview and further that cause. As we mentioned above, finding common ground may be tough because there might not be enough information available about your target, but it’s important to do the work before you give up on this route — finding common ground is the tactic that’s going to get you the highest response rates. Here are some examples of great ways to build common ground: Reference a project they worked on (maybe they wrote a blog post about it, mentioned it in a comment on Hacker News, or are a contributor to some open source project). Then… If possible, talk about relevant work you’ve done. It’s important not to make this connection too tenuous. If you do, this approach might backfire because they’ll start to get excited about you, only to be let down and ultimately feel tricked. If you do not have relevant work to share, ask a thoughtful question or two about theirs. Reference a controversial point of view that they hold, and affirm it in an authentic way. In the absence of something technical, it’s okay to reference something non-technical you've seen on their public profiles. We've seen candidates connect with strangers based on a shared love of Star Wars or Hearthstone. We understand that you won't always be able to find common ground. But if you can, it'll help you a lot, especially if you’re light on social proof or accomplishments. Selling yourself Selling yourself is usually about one of two things: Accomplishments: What have you built or created? Social proof: Have you worked at a top company or attended a top school? Some people are fortunate enough to have both, but many will have just one. That’s okay. We’ll work with what you have! Accomplishments What have you done that most other people haven’t? What have you done that, if you were to tell it to a stranger, would cause them to pause and think you're special or interesting? Below are some examples: You’ve had a blog post about a technical topic or a personal project do well3 on Hacker News, Reddit, or social media. Something you built at work got some great press when your company announced its last funding round. You refactored a piece of code at work, and now it runs 100X faster. You won a company hackathon. You’re a core contributor to a notable open-source project. Something you built is being used by a number of other people. Social proof Social proof is more about your pedigree. If you attended a top school or worked at a company known for having a high engineering bar, you should absolutely mention it! People won't click on links or open your resume until after they're interested, so you need to get them interested right away. That is: you should spoon feed them the most impressive-sounding things about you out of the gate. This may feel strange and uncomfortable, like you’re bragging. We assure you, however, that it’s necessary to get your target’s attention. They’re not thinking you’re bragging. They’re thinking, “Is this worth my time?” Your job is to convince them that it is. Also, don’t forget to link to your LinkedIn or personal website. Attaching a resume may feel too heavy-handed for a first conversation, as we discussed above. Here's an example of a prospective intern, leveraging both social proof and accomplishments, to write a compelling email. His email isn't super personalized, but he did make some effort to say that what we do at interviewing.io is important. Formulating a strong call to action A call to action is an invitation for the recipient to do something. You can go one of two ways with your call to action: ask for a job interview or start a conversation. Which you do should be a function of how much firepower you have in the way of social proof and accomplishments. It’s not fair, but if you can get your target’s attention with one or both of those, being bold and asking for a job interview makes sense. This approach can be effective, but it won’t work for most people… because most people don’t have enough social proof or accomplishments to justify this type of request. If you can’t leverage social proof or accomplishments, you’re going to have to work harder and bank entirely on building common ground, which will likely take some time and effort and involve a live conversation before they’re convinced to expend their social capital on you. If you’re asking for an interview, just come right out and say it. You can use the intern candidate’s email from earlier as a guide. However, this isn’t our preferred way to do it, and we really recommend starting a conversation instead. Take a look at the email below. In this email, the candidate doesn’t ask me about jobs — he just asks to meet to discuss a topic. Indeed, he’s done his research. I write a ton about judging resumes, and it’s a topic I could go on about for hours if you’ll let me. His email read like he’s genuinely interested in the subject and that we’d have a good conversation, so of course I responded. You’d be surprised how rare emails like this are. If you can find the topic your target cares about and write something that shows earnest, genuine interest, they’ll respond. With these emails, you’re asking for a conversation, not a job interview… because the conversation is what will hopefully prove to the hiring manager that you’re worth interviewing. Then, once you have a conversation, the hiring manager will walk away with the impression that you’re a competent, thoughtful human being who’s interested in this sort of work. From there, getting a job interview will feel like an afterthought. As such, don’t talk about jobs at all in this type of email, and in this particular case, don’t attach your resume — that will feel out of place and transactional. You can and should link to your LinkedIn so they know who you are and have some context. But spend the bulk of the email building common ground and coming up with an interesting reason for the two of you to talk. This approach is much more effective than asking for an interview out of the gate! You’re not going to land a job from one email, so, as with any seemingly insurmountable goal, it’s important to think of your outreach as a series of steps where you put one foot in front of the other. Like in sales, all you need is to get to a conversation. If your call to action is to set up a time to talk (which it probably should be because it’s specific), we recommend providing them with a time window. \"Would you want to meet up sometime?\" puts the burden on the recipient to pose a time, while \"Can we talk next Monday at 3pm?\" is problematic because, most likely, they aren't free then. Instead, try something like the candidate above did: \"Would you be available sometime within the next two weeks for a thirty-minute call? I'm free most weekdays between X and Y and can pretty much do any time on weekends if those are better for you.\" Two templates for you to use Below are two templates you can use for cold outreach. The first one is ideal but requires more effort and can't always be used. The second one is weaker but more generic. You can choose what fits your needs best. We expect both of these templates to be far more effective than throwing your resume into the blackhole of online portals. Template #1: Use this template if your target has an online presence This template includes common ground, accomplishments/social proof, and a call to action. It will get you the highest response rates, possibly anywhere from 25-50%. However, it can be challenging to use because it requires you to 1) do a deep dive into their online presence and 2) tie what you find back to something you’re doing. Sometimes, that tie-in might be tenuous or non-existent (in which case, maybe skip it). Hey {Their First Name},I’ve read your work on {insert some details about their writing}, and I {insert your thoughts on the work}.{If you can make the connection between their work and yours, talk about something similar you’ve been working on.}{If you cannot, ask them a specific, thoughtful question about your work. Don’t worry about making it “the perfect question” like you might when you attend a talk and want to sound smart. Any earnest question will do. You don’t have to use this as a chance to show off!}{Finally, close with a sentence or two about you, if you have some social proof or impressive accomplishments you can share.}Would you be up for a quick chat this week or next?Best,{Your name} {Insert 1-2 useful links about you. If you have a personal site, that’s great. If not, a LinkedIn will do.} Note that in this template, we leave some places for you to insert some social proof and your accomplishments. Even though this email is primarily about them and their work, and your references to yourself are primarily through that lens, it never hurts to drop in a few pieces of evidence that you’re someone who’s accomplished things and/or someone who looks good on paper. Template #2: Use this template if you don’t have anything except a LinkedIn profile for your target The reality is that you won’t always have enough information about your target to find common ground. In this case, you’ll lead with accomplishments/social proof and a strong call to action. We expect this template will get you response rates anywhere from 5-25%, depending on the strength of your achievements and pedigree. That said, we recommend treating this template as a last resort. Using it means you’ve exhausted any possibility of writing something personal. Hey {Their First Name},{List 2 things about you. They can be impressive accomplishments of yours or social proof, as above.}I’m really interested in the work you’re doing at {Company Name}. {If you know what team they’re on and are interested in that specific team or are familiar with that team’s accomplishments, great! If not, just write a few earnest sentences about why the company is interesting to you.}Would you be up for a quick chat this week or next?Best,{Your name} {Insert 1-2 useful links about you. If you have a personal site, that’s great. If not, a LinkedIn will do.} Keep your note short. The intent here is to make your target believe you’re an entity worth paying attention to, rather than them doing the easy thing: deleting your email. Regardless of which template you use, just like you have to manage your psychology when you prepare for technical interviews, you have to manage your psychology when doing outreach like this. You have to: Mentally prepare yourself for the slog of writing personalized emails and doing the requisite research. Get used to rejection. If you do write good emails and target the right people, you’ll have a much better hit rate than when you apply online, but you will still get ghosted a lot, and it will sting much more because, this time, you actually tried. But you know what? If you stick with it and do this right, within a few months, you’ll have a connection to a top-tier company. Now that you’ve girded your proverbial loins, it’s time to do the work. If you follow our advice, you’ll get 1-2 orders of magnitude more responses than from applying online, and with this approach, you’ll have at least a hiring manager at that company rooting for you! Footnotes: Footnotes RocketReach also has a LinkedIn-like faceted search you can use to find engineering managers, but we’ve found that it’s not nearly as reliable or rich as LinkedIn, which is why we recommend using LinkedIn for search and then RocketReach for email discovery. ↩ Recruiters should not contact candidates on their work email address, but that's because they're trying to make the candidate leave their job. You are trying to join the manager, which is why it's okay to use their work email address. ↩ Many people think that for something to be worth mentioning, it has to have gone viral. That’s simply not correct — in our niche space, a few hundred likes or a few thousand upvotes is already really impressive. ↩ Life is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedRelated postsWe analyzed 100K technical interviews to see where the best performers work. Here are the results.The unwritten rules (till now) of negotiating with MetaWhy resume writing is snake oilHow to sabotage your salary negotiations efforts before you even startStuff we write aboutRecessionSalary negotiationCompany NewsData Deep DivesDiversityGuest PostsHiring is brokenInterview tipsFor employers, how to hire betterHave interviews coming up? Study up on common questions and topics.MEDIUMMathematicsReverse IntegerGiven a 32-bit signed integer, reverse digits of the integer.MEDIUMData Structures and AlgorithmsConfusing NumberWrite a function that, given a room with 800 BIDDERS, identifies all the confusable numbers.EASYData Structures and AlgorithmsInfinite Binary PrintPrint out all numbers in binary, preserving leading zeros.SortingQuestions & tipsParsingQuestions & tipsLinked ListsQuestions & tipsMapsQuestions & tipsOrdered MapsQuestions & tipsArraysQuestions & tipsWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/blog/how-to-get-in-the-door-at-top-companies-cold-out-reach-to-hiring-managers-part-2",
          "author": "",
          "user_id": ""
        },
        {
          "title": "Are recruiters better than a coin flip at judging resumes? Here's the data.",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryBlog HomeAre recruiters better than a coin flip at judging resumes? Here's the data.By Aline Lerner and Peter Bergman | Published: May 1, 2024; Last updated: May 20, 2024This post is a very exciting first for interviewing.io because it’s about a proper experiment run by a real, live academic research lab. If you’ve been reading my work for the past decade, you know that I’ve always been something of an armchair researcher. I ran some experiments before starting interviewing.io, and since then, my team and I have kept it up. One of the experiments I ran before I founded interviewing.io was an attempt to figure out how good recruiters were at judging candidate quality based on resumes. I ran it 10 years ago and discovered that not only was everyone bad at judging resumes (about as accurate as flipping a coin), they all disagreed with each other about what a good candidate looked like. Even though these results were shocking at the time, the study had some serious limitations. First, I had no objective measures for which candidates were actually good. I was working as a recruiter at the time, so I knew whom I had been able to place, but that’s obviously not the be-all and end-all of engineering ability. Second, I had a non-representative sample of software engineers. Due to my brand, I had managed to attract a lot of excellent, non-traditional candidates — engineers who were actually very good but didn’t look good on paper. These types of resumes are the hardest for recruiters to judge, and the data was full of them. Finally, my sample size wasn’t that big: I ended up with 716 data points in total, only about half of which came from recruiters (the rest came from engineers and hiring managers — my original hypothesis was that they might be better at the task, but I was wrong… everyone was bad at judging resumes). So, now that I’m CEO of interviewing.io, with access to a lot more data, resources, and a team of excellent academics at Learning Collider, we decided to run this study again, but with a more rigorous treatment and better conditions, to see if we could replicate the results. This time, we focused just on recruiters, given that they’re most often the gatekeepers who decide which candidates get an interview. Below are all the details, but here’s the TL;DR: we reproduced my results from 10 years ago! Our new study showed that recruiters were only a bit better than a coin flip at making value judgments, and they still all disagreed with each other about what a good candidate looks like. In this piece, we also talk about: How far off recruiters were in their predictions and how much they disagreed with each other What recruiters say they look for vs. what the data shows they actually look for Why recruiters taking more time to parse resumes would lead to better outcomes (median parse time is just 31 seconds) Whether AI can do a better job at judging resumes (spoiler: yes, it can) The rest of this piece is co-authored by Peter Bergman, Tushar Kundu, and Kadeem Noray of Learning Collider. The setup In the real world, resumes (or LinkedIn profiles) are evaluated by recruiters in minutes — even seconds — and these evaluations are THE thing that determines who gets an interview. But what do these word walls tell recruiters? How predictive are their evaluations of actual interview success? Ultimately, how good are recruiters at judging resumes? To answer these questions, we designed a study approximating technical recruiters’ decisions in the real world. We asked1 76 technical recruiters (both agency and in-house) to review and make judgments about 30 engineers’ resumes each, just as they would in their current roles. They answered two questions per resume: Would you interview this candidate?2 (Yes or No) What is the likelihood this candidate will pass the technical interview (as a percentage)? We ended up with nearly 2,200 evaluations of over 1,000 resumes. The resumes in this study belonged to interviewing.io users (with their consent) — actual engineers currently on the job market. Collaborating on this study with interviewing.io is an ideal scenario, precisely because outcome data were available for comparison purposes. Each engineer in this study has completed multiple mock interviews on the platform. Performance in these interviews is quite predictive of performance in real interviews: top performers (roughly the top 5% of users) on interviewing.io are 3X more likely to pass technical interviews at top-tier companies than candidates from other sources. Even passing a single interview on interviewing.io is a strong predictor of outcomes; it's associated with a 32% increase in the chance of working at a FAANG company post-interview. Once we had recruiters’ evaluations of the resumes, we compared them to how those engineers actually performed on interviewing.io: skills scores, feedback from interviewers, and ultimately, whether they passed or failed their mock interviews. Recruiters’ resume judgments are just slightly better than a coin flip Question #1: Would you interview this candidate? In aggregate, recruiters in the study recommended 62% of candidates for an interview. But how did recruiter evaluations stack up against candidates’ performance on the platform? We calculated recruiter accuracy by treating each candidate’s first interview (pass/fail) as the truth, and recruiters’ decision to interview as a prediction. It turns out that recruiters chose correctly 55% of the time, which is just slightly better than a coin flip. Question #2: What is the likelihood this candidate will pass the technical interview? Recruiters predicted the likelihood that each candidate would pass the technical interview. In most hiring processes, the technical interview follows the recruiter call and determines whether candidates proceed to the onsite. Being able to accurately predict which candidates will succeed at this stage is important and should inform the decision about whether to interview the candidate or not. What we found most surprising is how far their predictions were from the truth: When recruiters predicted the lowest probability of passing (0-5%), those candidates actually passed the technical interview with a 47% probability. When recruiters predicted the highest probability of passing (95-100%), those candidates actually passed with a 64% probability. Below is a graph that shows recruiter predictions vs. actual performance. The x-axis is the bucketed recruiter rating. In other words, the first point is all the candidates that recruiters assigned a 0-5% likelihood of passing. The y-axis is the average interviewing.io pass rate for those candidates. The red dotted line represents 100% accuracy – in an ideal world, the higher a recruiter's ranking of a candidate, the higher their actual performance would be. The orange line represents reality – as you can see, there isn’t much correspondence between how recruiters predicted candidates would perform and their actual performance. Recruiters’ predictions below 40% underestimate these candidates by an average of 23 percentage points. Above 60%, they’re overestimating by an average of 20 percentage points. If this was predicting student performance, recruiters would be off by two full letter grades. Recruiters can’t agree on what a good candidate looks like Clearly, there is lots of noise in resume evaluations. Were recruiters’ noisy judgments at least consistent when reviewing the same resumes? Nearly 500 resumes were evaluated by more than one recruiter. Based on a random selection of two evaluations per resume, the overall likelihood of two recruiters agreeing to either interview or not interview a given candidate was 64%. Since recruiters also guess the probability a candidate will pass the technical interview, we can compare how different these guesses are for a given candidate. The average differential between two randomly selected recruiters’ evaluations of the same resume was 41 percentage points. So, let’s say one recruiter predicts a 30% probability the candidate would pass; another recruiter evaluating the same resume would predict, on average, a 71% probability of passing. To further understand just how prevalent the disagreement is, we looked at the standard deviations for across-candidate evaluations and same-candidate evaluations: 0.34 across different candidates 0.32 across the same candidates So, when two recruiters are asked to judge the same candidate, their level of disagreement is nearly the same as if they evaluated two completely different candidates. The most sought-after resume attributes Despite the noise and variability in the study’s resume evaluations, there were some characteristics that recruiters consistently favored: experience at a top-tier tech3 company (FAANG or FAANG-adjacent) and URM (underrepresented minority) status (in tech, this means being Black or Hispanic). Most predictive for Question #1 (whether a recruiter would want to interview that candidate) was experience at a top company — these candidates were 35% more likely to be picked. Black or Hispanic candidates are also associated with an increased likelihood a recruiter would interview a candidate — by 21%.4 With Question #2 (how likely the candidate was to pass a technical interview), having a top company on your resume is associated with a 21% increase in the likelihood that recruiters believe the candidate will pass the interview. Compared to the actual pass rates, recruiters’ predictions of FAANG candidates are generally accurate (average 4 percentage point overestimate).5 Unlike the presence of a top company, URM status didn't appear to influence recruiter decisions here. How do recruiters’ stated reasons for rejecting candidates line up with actual rejection reasons? So, we know what recruiters tend to favor, whether they’d admit to it or not: 1) FAANG/FAANG-adjacent experience and 2) URM status. But what’s even more interesting than why a recruiter would say yes is why they would say no. When we asked recruiters to judge a resume, we also asked them WHY they made that decision.6 Below are recruiters’ stated reasons for rejecting candidates. As you can see, “missing skill” is the main reason by far, with “no top firm” a distant third. So, then, we wondered… How do recruiters’ stated reasons for rejecting candidates line up with reality? To figure that out, we analyzed the resumes that ended up in the rejected pile and looked at common traits. Below is a graph of actual rejection reasons, based on our analysis. The main rejection reason isn’t “missing skill” — it’s “no top firm.” This is followed, somewhat surprisingly, but much less reliably (note the huge error bars), by having an MBA. “No top school” and having a Master’s degree come in at third and fourth. Note that these top four rejection reasons are all based on a candidate’s background, NOT their skill set. The y-axis is the coefficient from regressing rejection on that variable. So, a coefficient of Y for a given trait means that trait is associated with a Y\\*100% percentage point increase in the likelihood of being rejected. Slowing down is associated with better decisions Another key piece of this study is time. In hiring settings, recruiters make decisions quickly. Moving stacks of candidates through the funnel gives little room to second-guess or even wait before determining whether or not to give a candidate the opportunity to interview. In our study, the median time spent on resume evaluations was just 31 seconds. Broken down further by Question #1 — whether or not the recruiter would interview them — the median time spent was: 25 seconds for those advanced to a technical interview 44 seconds for those placed in the reject pile Given the weight placed on single variables (e.g., experience at a top firm), how quickly recruiters make judgments isn’t surprising. But might they be more accurate if they slowed down? It turns out that spending more time on resume evaluations, notably >45 seconds, is associated with more accurate predictions — just spending 15 more seconds appears to increase accuracy by 34%.7 It could be that encouraging recruiters to slow down might result in more accurate resume screening. Can AI do better? As a gaggle of technologists and data geeks, we tested whether algorithms could quiet the noise and inconsistencies in recruiters’ predictions. We trained two local, off-the-rack machine-learning models.8 Just like human recruiters, the models were trained to predict which candidates would pass technical interviews. The training dataset was drawn from interviewing.io and included anonymized resume data (years of experience, whether they had worked at a top firm, and whether they had attended a top 10 school for either grad or undergrad), candidates’ race and gender, and interview outcomes.9 Despite the very limited types of data we input into both models, when presented with out-of-sample candidate profiles, both models made predictions more accurately than human recruiters. Random Forest was somewhat more accurate than recruiters when predicting lower performing candidates. XGBoost, however, was more accurate across the board than both the Random Forest model AND recruiters. Where does this leave us? In this section, when we say “we,” we are speaking as interviewing.io, not as the researchers involved in this study. Just FYI. Advice for candidates At interviewing.io, we routinely get requests from our users to add resume review to our list of offerings. So far, we have declined to build it. Why? Because we suspected that recruiters, regardless of what they say publicly, primarily hunt for name brands on your resume. Therefore, highlighting your skills or acquiring new skills is unlikely to make a big difference in your outcomes. We are sad to see the numbers back up our intuition that it mostly is about brands.10 As such, here’s an actionable piece of advice: maintain a healthy skepticism when recruiters advise you to grow your skill set. Acquiring new skills will very likely make you a better engineer. But it will very likely NOT increase your marketability. If enhancing your skill set won’t help, what can you do to get in front of companies? We’re in the midst of a brutal market, the likes of which we haven’t seen since the dot-com crash in 2000. According to anecdotes shared in our Discord community, even engineering managers from FAANGs are getting something like a 10% response rate when they apply to companies online. If that’s true, what chance do the rest of us have? We strongly encourage anyone looking for work in this market, especially if you come from a non-traditional background, to stop spending energy on applying online, full stop. Instead, reach out to hiring managers. The numbers will be on your side there, as relatively few candidates are targeting hiring managers directly. We plan to write a full blog post on how to do this kind of outreach well, but this CliffsNotes version will get you started: Get a LinkedIn Sales Navigator account Make a target list of hiring managers at the companies you’re interested in Figure out their emails (you can use a tool like RocketReach), and send them something short and personalized. Do not use LinkedIn. The same way that you don’t live in LinkedIn, eng managers don’t either. Talk about the most impressive thing you’ve built. Ask them about their work, if you can find a blog post they’ve written or a project they’ve worked on publicly. Tie those two things together, and you’ll see a much higher response rate. Writing these personalized emails takes time, of course, but in this market, it’s what you need to do to stand out. Advice for recruiters We know that recruiting is a tough job, especially in the current climate, where there are more applicants than ever and fewer recruiters to parse through them. So, it rationally makes sense to us that a recruiter would spend no more than 30 seconds per resume and focus primarily on looking for top brands. We hope, though, that this piece may have given a measure of pause about your approach, and we’d like to leave you with two actionable pieces of advice. First, if you do nothing else, please slow down. As you saw above, taking just 15 extra seconds to read a resume could improve your accuracy by 34%.11 Our second piece of advice is this. Freada Kapor Klein from Kapor Capital coined the term “distance traveled” more than two decades ago. It refers to what someone accomplished, in the context of where they started. For instance, Kapor Klein recommends that, in their admissions processes, universities should consider not just the number of AP tests a candidate has passed but the number of AP tests divided by the total number offered at their high school. For example, if an applicant took 5 AP tests and their school offered 27, that paints a very different picture from another applicant who also took 5 AP tests when that’s the total number offered at their school. Kapor Capital uses distance traveled as one of their metrics for determining which entrepreneurs to fund. One can easily apply this concept to hiring as well. Take a look at the resume below. \"John\" (name has been changed; scrubbed resume shared with permission) studied chemical engineering and worked his way into software engineering by starting as a service engineer focused on pen testing. In the meantime, he completed a bootcamp, attended the Bradfield School of Computer Science (a school dedicated to teaching computer science at a depth beyond what many university programs, and certainly most bootcamps, offer), and ended up with a senior title in just three years. John was consistently rated poorly by recruiters but is one of the top performers on interviewing.io. It takes just a bit more time, so please spend a little longer reading resumes, and evaluate candidates’ achievements in the context of where they came from. Think about the denominator. But don’t think for a moment that we recommend that you lower the bar — absolutely not. On interviewing.io, we regularly see candidates like John objectively outperforming their FAANG counterparts. What this means for our industry The last time I did this research, I wrote about how being bad at judging resumes isn’t anything to be ashamed about and that comes down to the resume itself being a low-signal and not-very-useful document. I held that same opinion for the last decade (and even wrote a recent post about how AI can’t do recruiting)… right up until we ran this study and successfully built two ML models that outperformed recruiters. So, I stand corrected. As you saw above, both models were limited – they were looking at the same types of features that recruiters do when they quickly scan a resume, certainly fewer features than recruiters have access to. But, despite that, the AI models still outperformed humans. What happens then, if you can build a model that behaves like a recruiter who really slows down and reads everything? These results make me believe that resumes do carry some signal, and you can uncover it if you carefully read what people write about their jobs and themselves and also analyze how they write it. Unfortunately, this takes more time and effort to uncover than most human recruiters are able to devote. And, in retrospect, that’s a good task for AI. Though we haven’t built a model like that for this post, I’m optimistic that we may be able to do it in the future. As I said in the AI piece I linked above, in order for AI to do useful recruiting work, rather than just perpetuating the biases that human recruiters hold, it needs a data set that contains some objective measure of performance. Most recruiting AI models today do one of three things: glorified keyword matching, training on what recruiters prefer (the outcome is whether a recruiter would want to talk to the candidate, NOT whether the candidate is good), or live on top of existing tools like ChatGPT (which we recently showed doesn’t perform very well and is biased against non-traditional candidates). These three approaches just result in the wrong thing being done, faster. I hope that, in the not too distant future, we can use AI to make less-biased decisions, using meaningful performance data. And I hope that this type of AI solution can get adoption among the recruiting community. Footnotes: Footnotes Participating technical recruiters were paid a base rate and then received additional $$ for each accurate prediction. ↩ Different roles have different requirements. To correct for that, we asked each candidate to specify which eng role they were applying for: Software Engineer (back-end or full-stack), Mobile Engineer, Front-end Engineer, ML Engineer, Data Engineer, or Engineering Manager. Then we prompted recruiters to evaluate them specifically for that role. If no role was specified by the candidate, the default role to evaluate for was Software Engineer (back-end or full-stack). ↩ Top firms = Airbnb, Amazon, Anthropic, AWS, Apple, Asana, Atlassian, Bloomberg LP, Checkr, Coinbase, Coursera, Cruise, Dropbox, Etsy, Facebook, Flexport, GitHub, Google, Gusto, HashiCorp, Instacart, Instagram, Jane Street, Jump Trading, Khan Academy, LinkedIn, Lyft, Medium, Microsoft, Mozilla, Netflix, Oculus, OpenAI, Palantir, Peloton, Pinterest, Postmates, Quora, Reddit, Robinhood, Roblox, Salesforce, Segment, Slack, Snap, Snowflake, SpaceX, Spotify, Square, Stripe, Tesla, Thumbtack, TikTok, Twilio, Twitch, Twitter, Two Sigma, Uber, Udemy, Waymo, Whatsapp, Yelp, and Zoom. ↩ We corrected by FAANG & FAANG-adjacent experience (and all of our other variables) before making this statement, i.e., the effect existed for engineers from underrepresented backgrounds who did not have FAANG/FAANG-adjacent companies on their resumes. We expect that recruiters favor underrepresented minority candidates because of guidelines from their employers to focus on sourcing these types of candidates, as part of DEI initiatives. Discussion about the magnitude of this effect and its implications is out of scope of this piece. ↩ Interestingly, recruiters might penalize, for example, alternative education. Candidates with only alternative education pathways post-high school — coding bootcamps or digital certifications — appeared to be penalized by recruiters in this study. However, with limited observations (n=11), it’s inconclusive without further study. ↩ That field was optional, so most of the reasons recruiters provided were in cases when they said no — presumably because the reasons for saying yes may have seemed self-evident. ↩ It’s not that recruiters who generally take their time make more accurate judgements. Any recruiter slowing down might make them better at judging resumes! ↩ It’s important to stress that neither algorithm was custom-built. The models, one using a Random Forest algorithm and the other an XGBoost algorithm, are distinct but interrelated approaches akin to Decision Tree algorithms. Decision trees sort data into groups based on features. Random forest algorithms combine multiple decision trees to improve predictions. XGBoost builds multiple decision trees one after another, with each new tree focusing on prediction errors from the previous trees. ↩ Training data excluded data in this study. We take user privacy very seriously, and we want to stress that all models were local and anonymized and that no data in this study was shared with cloud LLMs. ↩ To see a particularly egregious example of recruiters favoring brands over substance, take a close look at this fake resume that got a bunch of recruiter responses. And this one too. ↩ We haven’t proven causality here, but when we just scoped our analysis to the same person, it appeared that taking more time did help (in other words, it’s not just that recruiters who spend more time usually are more accurate; it’s the added time). Still, this is something that merits more work, and we'll try to investigate it causally in the future. ↩ Life is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedRelated postsThe definitive list of companies who are hiring engineers right nowWe built voice modulation to mask gender in technical interviews. Here’s what happened.We ran the numbers, and there really is a pipeline problem in eng hiring.Resumes suck. Here's the data.Stuff we write aboutRecessionSalary negotiationCompany NewsData Deep DivesDiversityGuest PostsHiring is brokenInterview tipsFor employers, how to hire betterHave interviews coming up? Study up on common questions and topics.MEDIUMData Structures and AlgorithmsMaximum SubarrayGiven an integer array nums, find the subarray with the largest sum, and return its sum.MEDIUMData Structures and AlgorithmsPartition to K Equal Sum SubsetsGiven an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.MEDIUMData Structures and AlgorithmsFind Peak Element in a 2D ArrayGiven a two-dimensional binary matrix where 1 represents water and 0 represents land, mutate the matrix in place and return the matrix with the highest peak maximized.Union FindQuestions & tipsPriority QueuesQuestions & tipsHash TablesQuestions & tipsSortingQuestions & tipsMemoizationQuestions & tipsHash MapsQuestions & tipsWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/blog/are-recruiters-better-than-a-coin-flip-at-judging-resumes",
          "author": "",
          "user_id": ""
        },
        {
          "title": "The unwritten rules (till now) of negotiating with Meta",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryBlog HomeThe unwritten rules (till now) of negotiating with MetaBy Aline Lerner | Published: February 27, 2024; Last updated: February 25, 2025If you don't like reading, here's me presenting the contents of this blog post in a video. Pick your poison. EDIT: This post is based on stories from users who were interviewing for E4-E6 SWE and MLE roles at Meta. Other, more specialized roles may have different processes than what's described here. EDIT 2: As of Q1 2025, it looks like Meta is sometimes foregoing team matching in favor of driving candidates to their Monetization org (which apparently has a lot of open headcount). If this happens to you, after you pass the hiring committee, instead of entering team matching, your recruiter will tell you that you’ve been assigned to this particular org and, if you proceed, you’ll just get an offer. You won’t get to talk to your future manager, and you’ll find out team details a week after you join. From what we know, it’s possible to insist on team matching instead, with the downside that it’ll take an unknown amount of time rather than certainty. Why does this matter? If you’re looking to use your Meta offer primarily as leverage with other companies, this is a great thing because you’ll get numbers quickly. If you’re seriously interested in Meta, then this could be good or bad and depends where you are in the process and how much you want to work on monetization versus other things/how much you want to meet your manager before you work for them. So if you’re seriously interested in Meta, whether this is good or bad depends on where you are in the process. If you need them to move quickly, it’s great because you know you won’t be stuck in team matching. However, if you need them to slow down because you aren’t as far along with other companies or because you want to work in a different org, you may want to ask your recruiter to stick with the old team matching process. In our experience, it’s ok to ask this. Your recruiter may not tell you outright that that’s an option, but if you ask, they will probably do it. Of course, you may be stuck longer than you want. But at least then you will have more of a say in what you work on. At interviewing.io, one of the services we offer our users is salary negotiation. Even though I’m the founder, I still do many of the sessions myself because they give me an invaluable insider’s perspective on what’s actually going on in the engineering market, what different companies’ offers look like, how companies extend offers, what kinds of deadlines they give, and how much they go up in compensation, under what circumstances. Access to this kind of data is great because it helps me make better business decisions. But sometimes I see questionable patterns of behavior among companies. Recently, I’ve observed a string of practices at Meta that I find reprehensible, and that’s what this post is about. I’ve seen the same practices with enough candidates, and across enough different titles and positions, that it’s become clear to me that they are not isolated incidents or a rogue recruiter’s doing but rather a consistent implementation of a deliberate strategy that comes from the top. I’m writing about this for two reasons. First, if you’re negotiating with Meta, you need to know how they operate and understand the unwritten rules of the game. If you do not know the rules, you will fail — long before you even start negotiating. Second, I’m hoping that someone at Meta sees this post and that maybe it’ll spark an internal discussion about changing the rules. By the way, if I’m wrong, I will gladly issue a retraction and a public apology. Please contact me if you’re a recruiter at Meta and find something incorrect in this post. My email is aline@interviewing.io. Lastly, if you’re about to interview there or are interviewing there already, please read our free, long-form guide to their interview process and questions. Meta basically has a monopoly on FAANG hiring right now I mentioned above that we do salary negotiation, but our main business is mock interviews. We offer anonymous mock interviews in the style of a bunch of different companies (mostly FAANGs). This means we know how many people are practicing for interviews at Google vs. Meta vs. other FAANGs, and that lets us guess (pretty accurately) how much hiring is actually happening at these companies. You can read in way more detail about how all the FAANGs are doing in our recent blog post where we made 2024 predictions based on our proprietary data. But while I was writing that post, I noticed something odd. Meta was hiring way more engineers than any of the other FAANGs. In fact, Meta hiring is up more than 10X since January of last year. You can see that more recently Amazon has picked up a bit, but it’s very recent and not enough to drive major change in other companies’ behaviors (at least not yet). And, yes, Netflix is hiring too, but Meta’s eng team is more than 10X the size of Netflix’s, so in the absolute, Netflix’s hiring volume isn’t enough to balance Meta out. For all intents and purposes, Meta’s the only FAANG that’s really hiring at scale — and they’re currently getting away with treating candidates really poorly as a result. How Meta negotiates, given their effective monopoly on eng hiring Here’s how Meta runs their hiring process. These practices have been consistent across every negotiation client we’ve had in the past 6 months or so. Meta’s hiring is centralized, which means that you enter one big interview process that’s completely divorced from which team you might end up on and you interview with people whom you might never work with again. If you do well, there will be a team matching component after you pass the onsite but before you get an offer1. With that in mind, here’s how they run their process, once you get the green light. Team matching. This can take days or weeks, depending on how many teams you speak to and how many conversations you have with the people on each team. You'll speak with hiring managers to gauge fit and chemistry, and if you’d like, you can also talk to peers. We've heard that sometimes you get the chance to talk to a handful of teams, and sometimes it's over 10. After your team-matching conversations, your recruiter will ask you to choose a team. In order to move forward, both you and the hiring manager have to opt in2. Likely down-level you. Sometime during team matching, you’ll probably find out that you’ve been down-leveled. Often, your recruiter will cite your performance in the system design portion (and sometimes the behavioral portion). According to a recent survey we did, something like 55% of Meta candidates get down-leveled (more likely for generalist SWE roles, less likely for more niche roles like ML). Make a lowball offer with just a few days to make a decision. Once you’re done with team matching, things get dicey. Your recruiter will make you a lowball offer that’s often $50k or more (!!) below the average TC on levels.fyi. Moreover, you usually just get a couple of days to make a decision. If you were down-leveled, your lowball offer may include a small signing bonus as a consolation prize. Refuse to negotiate unless you can show them other offers from comparable companies. Your recruiter will say something like, “If you’d like to increase your offer, I can take this to the compensation committee, but I need a compelling reason \\[i.e., another offer\\].\" If you have other offers, they will apologize for the lowball offer, citing that it’s “automatic numbers from our computer” and raise the numbers by $100K or more (in first year’s TC). If you do not, you will be stuck with a lowball offer, though you may be able to negotiate a small signing bonus if the offer didn’t come with one already. How to negotiate with Meta Below are the steps for negotiating with Meta in a hard climate where they have a monopoly on hiring. We hope that most of these won’t be necessary in the future. They are: Don’t share anything with your recruiter Make sure you have other offers Slow-play team matching Build rapport with every hiring manager you talk to Actually negotiate (this is the easy part) Don’t share anything with your recruiter We wrote a whole post about how to avoid sharing information with your recruiter and why this is so vital. If you share where you’re interviewing or how far along you are, or if you start negotiating prematurely, the strategies below won’t work. Please read our post on not shooting yourself in the foot during negotiations before you continue! You should also be aware of a few tricks specific to Meta recruiters. If you're not forthcoming about where else you're interviewing, they may say a few sneaky things. First, they may say something like, \"Well, we just want to know where you're interviewing so we can intro you to others who interviewed at those companies but ultimately chose Meta.\" Don't fall for that early in the process. It's a trap to get information out of you. You can always ask for those intros later, when you're negotiating and it's the right time information about your other offers. The other thing they do is fish, saying something like, \"Well, in case you're interviewing at {Google, Netflix, some other big company they don't want to lose candidates to}, just so you know, they move kind of slowly, so we may not be able to wait.\" There, the Meta recruiter's goal is to get you to say, \"Oh, no, don't worry, I'm not interviewing at Google!\" Now, you've lost leverage in their eyes because that's one less competitive company they might lose you to... and they'll be more confident about lowballing you later on. Make sure you have other offers As you may have guessed from reading the previous section, it’s critical to have other offers, and not just any offers but ones from top-tier companies who pay very competitively3. We realize that saying “have other offers” doesn’t capture the blood, sweat, and tears that go into months of interview prep, applications, emails, recruiter calls, and interviews. We know it’s hard, but as you’ll see, it makes a huge difference in your compensation. Getting those offers doesn’t start when you’ve received your Meta offer. It starts months before. Make sure that you get enough initial conversations with other FAANGs, FAANG-adjacent companies, and late-stage sexy startups to end up with at least one other offer, ideally at least two. Depending on your interview performance, this might be anywhere from 4 to 10 initial conversations.4 Slow-play team matching Having your offers come in around the same time is critical for any negotiation, but it’s especially important with Meta because they take such a hard line — without other offers, they will not meaningfully budge. Obviously, you’ll want to start your conversations with other companies well in advance of your Meta interviews and do everything you can to make sure they all come in at the same time. However, even with your best efforts, it’s not guaranteed that your timing will match up. Here’s how to make sure that your offers come in at the same time: slow-play Meta’s team-matching process. Team matching is actually the part of your Meta journey where you have the most leverage and power. Why leverage? At this point, they know they want you, but they can’t yet hold an offer deadline over you. We’ve already mentioned that once they make the offer, your recruiter is going to push very hard to have you accept, often giving you a deadline of something like two days. In your recruiter’s eyes, you’re a ticking time bomb, where for every day you don’t sign, the deal loses momentum, and your odds of signing drop off. Recruiters are also evaluated on how many candidates they close, so it’s in their interest to create a false sense of scarcity in order to rush you and to use high-pressure sales tactics to get you to seal the deal. And what power do you have? It turns out you can really control how long team matching takes, within reason. If you’re still wrapping phone screens with other companies, slow-playing is the best thing you can do. Here’s how to do it. We’ve recently heard that Meta is now insisting that hiring manager conversations happen in series, but even if Meta lets you talk to multiple hiring managers concurrently, try to serialize those conversations as much as possible. For instance, if you hear from your recruiter that you’re going to start team matching on a Monday, and they offer to set up some calls for Wednesday, ask to do the first call on a Friday and the next call the following Tuesday. When we advise our users to do this, we often get pushback because they’re worried that slowing things down will make them look disinterested/not serious. We promise you that’s not the case. The biggest risk you run when you slow-play team matching scheduling like this is losing the chance to work on a specific team. If you find that your recruiter has proposed what seems like the perfect team for you, you can and should prioritize doing that call as soon as possible. In addition to serializing your hiring manager conversations, for each team, ask to talk to a few individual contributors on teams that you’re serious about. This isn’t just a stalling tactic. These are the people you’ll be working closely with every day, and they’re the ones doing the job you may have in the future. They’re also less likely to do hard sells, and if you ask thoughtful questions, you’ll learn a lot about what to expect. We’re always surprised by how few candidates ask to speak to their future peers, out of a mistaken concern that asking for too much will make them look disinterested or unengaged. Just like with hiring manager calls, if you need to slow things down, we recommend scheduling calls with your peers a few days apart. Situations where slow-playing may bite you, and how to know the difference We have seen two instances when our advice about slow-playing could backfire. You probably remember when companies started to freeze hiring aggressively in mid-2022 — if you didn’t get matched before the ax came down, you were left out in the cold. Much more recently, we heard from some of our users that Meta put a pause on team matching for E4 roles (largely outside the Bay Area), and many candidates were stuck in a holding pattern (while Meta figured out headcount constraints, though it looks like it’s since been resolved, and picking back up in earnest. Slow-playing and then getting stuck is obviously an unfortunate situation, as is being on the wrong end of a hiring freeze, but these situations are rare, and in our humble opinion, not worth optimizing for — in most cases, you will not be dealing with an impending freeze or stalled matching. If you’re unsure about team supply or the state of hiring, you can do two things: Always ask your recruiter up front to share the number of teams that candidates have had the chance to talk to, on average, recently. Look at our real-time graph of FAANG hiring volume (as opposed to the graph above, which is a monthly snapshot). In this real-time graph, you can see what portion of our mock interview volume is dedicated to practice in the style of Meta, Amazon, and Google. Historically, our purchasing behavior has lined up very well with what’s actually going on in the market, and the rate of change in this graph should give you an idea of whether Meta is slowing down. As you can see, there was a dip in February (and one in December, but that almost always happens because hiring slows down over the holidays). If you see dips like these, you’ll want to make sure that you do (1) and ask your recruiter about the situation inside. You may also choose not to slow-play for too long. There's one more situation where slow-playing may bite you. If you match with a team and really click well with the manager, to the point where you have your heart set on it, it may be wise to accept that team instead of trying to drag things out. We've heard of times where, even if the candidate asked the manager about open headcount and confirmed they didn't have to rush, the role got filled from under them (they were able to talk to other teams afterwards but missed the chance to be on that specific team). If a specific team feels irreplaceable to you and you'd be crushed if you didn't get it, then that may be more important than maximizing your negotiation. Build rapport with every hiring manager you talk to Outside of using the team-matching process to control your timeline, there is one other important tactical piece of advice: Do your best to build rapport with hiring managers. As we said above, recruiters are trying to close the deal. That’s their job. Hiring managers, on the other hand, are trying to lay the groundwork for a good working relationship with you. As a result, their interests are much more aligned with yours. Of course, they still want to close you, but it’s not worth it to them to employ high-pressure tactics, and it’s not something they’re trained in or comfortable with (in fact, many of them hated these tactics when they were on the other end of it while looking for work)5. As such, hiring managers will generally be a lot more transparent with you about how much time you actually have to make a decision, and their answers will likely be very different from the ones you get from recruiters. We’ve advised all of our Meta candidates to ask their prospective hiring managers about when they realistically have to make a decision by, and the differences between what the hiring manager has told them (“Take your time; you have a few weeks at least.”) and what their recruiter has told them (“We’re talking to a lot of candidates for that team. To ensure your spot, you should make a decision in the next few days.”) are stark. There’s simply no downside to building rapport with hiring managers. At worst, you make a professional connection. At best, you get a head start on a great working relationship with your new boss. One practical note: Always ask your hiring manager for their email address in case you have more questions later. This way, if your recruiter starts telling you that you need to make a decision by Friday, you can ping your hiring manager, explain that you’re still thinking, and ask if it’s OK to take a few more days. Almost always they will say yes. Actually negotiate (this is the easy part) If you’ve done everything else in this post, the negotiation is the easy part. By now, you’ve wrapped up team matching, chosen a team, and have likely gotten an aggressive offer deadline. You have also not shared any offer details till now. As we said at the beginning of this post, the success of your strategy hinges on the recruiter not being aware of the other companies you’re interviewing with. This will be the first time they find out about it, and that will put them on their proverbial back foot. To respond to the offer, you can send an email6 that looks something like the below. The details will differ, and how much you reveal about the other offers will vary, but here’s the general idea. Hey \\[Recruiter name\\], Thank you so much for the offer, for working with me throughout this process, and for all your help with team matching. I wanted to share some details with you. I currently have offers from {Company 1}, {Company 2}, and {Company 3}. {Company 1} has offered me a significantly higher base salary of $220k. {Company 2} has a comparable base but has offered me significantly more equity: $500k. I know {Company 2} is a startup, but they’re late stage and handing out RSUs. Those RSUs are as valuable to me as public company equity. Finally, {Company 3} has thrown in a meaningful signing bonus, and their performance bonus is actually at 25%, not 15%. I’m very excited about the opportunity to work at Meta and about the team. {Insert some authentic reasons why you’re excited about the company, the team, your new boss, etc.} It’d be great to see a meaningful increase in compensation to make my decision easier. Thank you, and I look forward to hearing from you. By the way, this isn’t the only approach you can take, and with other companies, you might have better luck with the Reverse Used Car Salesman. However, in our experience, if you don’t share offer details, your Meta recruiter will immediately ask you to share, so you might as well control the flow of information. In the template above, I’ve assumed that not all of your offers are stronger than Meta’s across the board, which is why I’ve cherry-picked which pieces to share. Sometimes, if you’re lucky, you’ll have multiple offers that have a higher base, more equity, and a higher signing bonus. In that case, it’s less of a game of skill — just throw the numbers at them, and they’ll exceed the other offers without much prompting. If you run this play, your recruiter will apologize for low-balling you, blaming the “computer” for giving them those numbers. Then, like clockwork, you will see a $50k to $150k jump in your offer (precisely how much depends on where your other offers are from and how strong they are).7 Now, whether you take that offer is up to you. Some closing thoughts. I’m a capitalist. Meta’s behavior here is aggressively capitalistic, if short-sighted – once other FAANGs start meaningfully hiring again, and Meta employees figure out that there’s a $150k comp differential between people with the same job title, they’re going to pay the piper and likely see a bunch of attrition. Ultimately, the market will correct these practices. However, I also believe that individuals have the right and duty to be as informed as possible and to wield whatever weapons in their arsenal to advocate for themselves, rather than waiting on the mercy of slow, indifferent market forces. As such, we hope this post has given you some ammunition in your negotiations and helped reduce the information asymmetry between you and Meta, a huge, aggressive player with basically a monopoly on eng hiring at the moment. And we hope that if anyone from Meta is reading this, it’ll spark some internal conversations about what’s right. And if they don’t, other FAANGs’ recruiters will swoop in soon enough. Want to know if you’re ready to interview at Meta? Do anonymous mock interviews with real Meta interviewers, and see exactly where you stack up.See available times Footnotes Footnotes How team matching works changed fairly recently. In the past, you’d get an offer before you matched with a team and do a 6-week “bootcamp” where you’d get up to speed on Meta’s tech stack, infrastructure, and systems, followed by a multi-week “speed dating”-esque team matching cycle. Bootcamp still exists, but now it's much shorter (2-4 weeks), and the focus is getting new engineers ramped up on generic tools. After that, new engineers continue to ramp up on their specific teams. ↩ We’ve recently heard that Meta may now be insisting that team matching conversations happen in serial, i.e., you can only do one at a time. However, this doesn’t meaningfully change our advice. ↩ You might say, “Aline, why can’t I just make up offers?” We could never, in good conscience, advise that. It’s unethical, and though I’d argue that while Meta’s negotiation practices are also unethical, that’s not the way to win. Outside of ethical considerations, while the risks of getting caught are low, they’re not zero. Lying about offers, in our mind, is the last refuge of the incompetent. ↩ The advice in this post is orthogonal from your career goals and what you want to work on. This blog post is about navigating an unfair system filled with opaque rules while maximizing your cash. It is not about self-actualization, though we’d argue that creating the most optionality for yourself helps with self-actualization as well. You can also talk to smaller companies and use your big-co offers as leverage to increase your startup equity. There’s nothing wrong with that, but more detail on optionality and self-actualization is outside the scope of this post. ↩ Of course, some hiring managers will use high-pressure sales tactics or create false timelines to try to close you. But that’s the exception rather than the rule. You can decide if that’s something that you want to weigh when judging whether or not you want to work for them. ↩ We strongly urge you to avoid negotiating over the phone and over text, whenever possible. Your recruiter does 5 of these calls a day. You might do one of these calls every few years. Do the hard part over email. It’s the best way to level the playing field. Read this post to learn how to avoid synchronous phone negotiations (just look for “phone”). ↩ One advanced maneuver is to pit all your other companies against each other and raise up their initial offers BEFORE talking to Meta. We’ll likely write about how to run this play in a future post. ↩ Life is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedRelated postsAre recruiters better than a coin flip at judging resumes? Here's the data.We co-wrote the official sequel to Cracking the Coding Interview!How to get in the door at top companies: cold outreach to hiring managers. Part 2 of 2.How hard is it to cheat in technical interviews with ChatGPT? We ran an experiment.Stuff we write aboutRecessionSalary negotiationCompany NewsData Deep DivesDiversityGuest PostsHiring is brokenInterview tipsFor employers, how to hire betterHave interviews coming up? Study up on common questions and topics.HARDSystem DesignDesign WhatsAppDesign a message app system and client (e.g. WhatsApp) supporting a list of requirements.MEDIUMData Structures and AlgorithmsInteger ReplacementGiven an integer as an input, replace all the digits ‘0’ with ‘5’ in the integer.EASYData Structures and AlgorithmsLucky Numbers in a MatrixGiven an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.Binary TreesQuestions & tipsTreesQuestions & tipsSliding WindowQuestions & tipsRecursionQuestions & tipsPriority QueuesQuestions & tipsParsingQuestions & tipsWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/blog/how-to-negotiate-with-meta",
          "author": "",
          "user_id": ""
        },
        {
          "title": "How to sabotage your salary negotiations efforts before you even start",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryBlog HomeHow to sabotage your salary negotiations efforts before you even startBy Aline Lerner | Published: August 23, 2023; Last updated: September 6, 2024Note: If you’d like a practical primer on negotiation, read my previous post on negotiation first — it tells you exactly what to say in a bunch of situations. This post is longer and more academic, but of course I include some practical tips and teach you what to say in a few situations, as well. At interviewing.io, we’ve coached hundreds of people through salary negotiation. We’re good at it — our average user gets $50k more in cash, and we have a 94% success rate. Having done this a lot, we’ve seen our users make the same two mistakes, over and over, BEFORE they start working with us. These mistakes are costly and make it harder for us to do our jobs. Our advice is applicable to everyone, but I wrote this post primarily to share with interviewing.io’s user base, so that future clients of our negotiation service don’t shoot themselves in the foot. These are the two things you must avoid. Both involve how you talk to recruiters at the start of your job search, way before there’s an offer: Revealing information too early in the game Negotiating before you’re ready In this post, I’ll explain why these two mistakes routinely sabotage salary negotiation efforts and what to say to recruiters instead. In a nutshell, if you can just be in “passive information gathering” mode (more on that later) for most of your recruiter interactions, you’ll be golden. It’s hard to not to share info about your job search with your recruiter, especially as you build more rapport with them, but we’ll tell you exactly what to say instead. Before we get into all of that, I want to go over two foundational things about negotiation. Recruiters are not your friend, and they don't work for you. What negotiation is and what it’s not Recruiters are not your friend, and they don’t work for you “It is difficult to get a man to understand something when his salary depends on his not understanding it.” -Upton Sinclair I used to be a recruiter. I ran my own agency, and I also worked in-house before starting interviewing.io. That means that I’ve had to struggle with the tangled incentive structure that comes with being a recruiter (see the section called “You should write down your principles”). There’s always a tension — recruiters are, by and large, good human beings who genuinely want to help their candidates, but they also have an employer they’re beholden to, as well as a comp/bonus structure that rewards certain behaviors, some of which run counter to candidates’ best interests. There’s some distinction between in-house recruiters and third-party recruiters (recruiters who work for an agency that does placement, rather than a specific company that’s hiring engineers). Third party recruiters My general policy with third-party recruiters is to not tell them ANYTHING and to always deal directly with the companies they introduce you, once you establish a point of contact there. You should assume that anything you tell your recruiter is going to get back to every company you’re working with. Why? Because their primary objective is to place your butt in the seat of one of the companies they’re working with, and they will do whatever they need to do to make the deal happen. Often, those things will run counter to your interests. A big misconception that many candidates labor under is the idea that because third-party recruiters get paid every time they make a placement, their interests are fundamentally aligned. At a high level, this is kind of true, but once you dig into the details you'll see a lot of nuance. A recruiter, depending on market conditions, gets anywhere from 8%-25% of the candidate’s base salary when they make a placement. In the current climate, it’s around 10%. However, that cut is going to the recruiting agency as a whole rather than to the individual recruiter — you will almost always end up working with large agencies rather than a sole-proprietor shop where the owner gets to take all of it home. Let's say that you get an offer with a base salary of $150,000. You talk to your third-party recruiter and tell them that you would like more money. The recruiter may go to the hiring manager and try to advocate for you, but they're not going to push very hard because the incremental difference in their cut is going to be pretty small and to them the thing that matters most is getting butts in seats. After all, they're evaluated on the number of hires they make, first and foremost, independent of comp. Understanding that, let's do the math anyway. Say that they’re able to risk closing the deal and get you $165k. Before, the agency would have gotten paid $15k. Now the agency gets paid $16.5k. That incremental $1.5k isn’t worth risking a deal over (even a few thousand dollars would not justify jeopardizing the deal). On top of that, the individual recruiter is only going to maybe get a few hundred dollars total from that increase. So for them the difference really isn’t worth it. Third party recruiters are incentivized to get the deal done, not to risk the deal by negotiating hard for you. Moreover, because they’re incentivized to get the deal done, you should assume that your recruiter will share anything you share with them with the company or companies they’ve introduced you to. If you tell them that a company is your first choice and that you’re tempted to accept, they will likely share that with the company and may even recommend that they not raise your comp, since you’re already so enthusiastic. If you share that you’re not very interested in a company, and the recruiter has other candidates they’re presenting, they will prioritize those candidates’ experience over yours and will possibly tell the company not to invest in you as hard. In-house recruiters What about in-house recruiters? In-house recruiters may or may not get a bonus for hires that happen on their watch; it depends on the company. But if they do, that bonus is generally NOT tied to your compensation, and in some cases, they may get a bigger bonus if they’re able to negotiate you down. At big companies, in particular, in-house recruiters follow a playbook. They’re trained to make offers within specific bands, and they’re trained to mobilize such that they don’t lose candidates to other big companies — if you wave a Facebook counteroffer in front of Google, they will act. If you tell them you’re interviewing at a startup, they will not, because they know that startups don’t pay as much. They’re actually evaluated on how well they follow the playbook. Because of that, there is no reason to assume that their incentives align with yours. They’re incentivized, first and foremost, to follow the rules their head of department sets for them. This is true for how they evaluate candidates, who they let through, and how they read resumes. And it’s definitely true for how they negotiate. If you’re interested in peeking behind the curtain on how recruiters think, I interviewed three of the best ones in the industry recently. You can watch that below: I’ll close this section the way I began it. Recruiters want to help, and many are rooting for their candidates. But they’re also operating inside a box, and that box isn’t set up to put your interests first. What negotiation is and what it’s not Probably because of bad books and airplane magazine ads (for those of you old enough to remember those), people often think that negotiation is all about saying the right thing, or how firm your handshake is, or any other amount of silly nonsense. The reality is that negotiation is all about preparation and leverage. Don't forget to prepare for your technical interviews too. Sign up today for anonymous mocks with senior engineers from top companies.See available times Preparation and leverage means doing the work to make sure that you have multiple offers, that all your offers come in at the same time, and that you don’t tip your hand too early. Laying this foundation is 80% of the work. You’ll need to slow some companies down, speed some companies up, and hold off questions from recruiters until you’re ready to negotiate, and not before. If you do this right, the actual negotiation part will be easy and almost a foregone conclusion. Is it possible to negotiate when you don’t have multiple offers and when you haven’t done the foundational work? Sure, it is, and we’ve sometimes had success with our users doing that. But it’s much harder, and the ceiling on how much more money you can get is lower. With all that out the way, let’s talk about how the two biggest mistakes people make and how to not make them! Mistake #1: Revealing information before you’re ready to negotiate You’ve probably never been arrested, but if you’re like me, you’ve watched a lot of police procedurals on TV. You know the bit where they read the suspect their Miranda rights? They start like this: You have the right to remain silent. Anything you say can and will be used against you in a court of law… Talking to recruiters is exactly the same, and one of the biggest mistakes we see our users make is sharing information too early. This is generally the only mistake we can’t walk back — once you share information, you can’t undo it, and sharing information actually has no upside, only downside. When you’re ready to negotiate, you’re doing so deliberately because you already know the state of the world, and you’re choosing to reveal the parts that set you up for success. Before that, you’re just revealing stuff that can be used against you. Specifically, do not share with recruiters anything about your salary history (though it’s illegal in many states to ask this directly, there are indirect ways of asking, and many still do), your salary expectations, where else you’re interviewing, and how far along in the process you are with other companies. In short, don’t share any information about money or other interviews. The main question recruiters ask up front about money is: “What are your compensation expectations?” They claim that it’s because they want to make sure that you’re not so far off in your expectations that interviewing with that company would be a waste of time. This is a nonsense reason — very few companies pay so much below market that it would be a nonstarter. Those companies know who they are, and they know to give you a heads up that they pay below market. Moreover, with the recent advent of companies sharing salary bands, you’ll have some idea if they're grossly below market before you interview. The real reason recruiters ask about compensation expectations is so that they can use it against you later in negotiations. As such, if you answer this question with a number, you set an artificial ceiling on your offer. Do not even utter a single number to a recruiter until you’re ready to bargain. Do not go on levels.fyi and comment on the ranges listed for your level, even if you’re currently underpaid and an average offer from them would be life changing. Do not say a number first — ever. You can see exactly what to say when you get asked about compensation expectations in the section called “How to handle recruiter calls” below. The most obvious way to lose leverage is revealing information about money. The other way to lose leverage is by sharing information about where else you’re interviewing. If you share this information, you risk prematurely scaring off smaller companies because they don’t think they can win in a bidding war with FAANG. You also risk cornering yourself into a situation where the company knows your options are limited, and they might be inclined to lowball you as a result. Finally, you risk getting an exploding offer to try to force you to make a decision before you’re ready. Below are some examples that I hope will drive these points home. Example #1: You’re interviewing at Google, Meta, and two startups Let’s say that you’re currently interviewing at Google, Meta, and two startups (let’s call them A and B). You’re at the onsite stage with Google, you’re doing technical phone screens at both startups, and you’re just doing your first recruiter call with Meta. This is actually a very strong position to be in! Of course, your Meta recruiter asks you about your comp expectations and where else you’re interviewing. If you reveal your comp expectations, it will be hard to walk them back: Let’s say that you currently work at a startup and make $150k in cash with some amount of equity. You go to levels.fyi or a similar site and look up Facebook’s salary bands for the role you’re targeting. Let’s say those bands for total comp are $250k-$350k. Hell, that’s way more cash than you’re making now, so you decide to share that range, thinking that if those are their bands already, it does no harm. That’s reasonable, except that let’s say Google ends up making you an offer, and it’s $400k (we’ve seen this scenario happen to a bunch of our users). Now you have to walk back what you said, in which case your recruiter will invariably ask why. And now you have to reveal, before you’re ready, that you have a Google offer, which means you’ll probably end up revealing that it’s for $400k. Now you’ve set an artificial ceiling for your Facebook counteroffer to be $400k as well, when in reality that ceiling may have been closer to $450k or even $500k. If you reveal that you’re at the onsite stage with Google and talking to some startups, here's what will happen: Your recruiter will do the math and start asking you in a few weeks if you got to team matching. Now Meta knows that Google is the only possible offer on the table that they should be worried about. They (and other big companies) don’t take startup offers nearly as seriously because equity is monopoly money 'til it’s not… and even if you don’t reveal the cash portion of your comp, they’ll assume it’s smaller than what they’re offering. If you didn’t pass the onsite, it’s going to be hard to not share that when you’re persistently asked about it, unless you lie (which I absolutely do not condone). Now you’ve lost leverage because Meta knows that you cannot possibly have any other big tech company offers. If you DO perform well in your Google onsite, that’s great, but team matching can take a while (yes, I know Google is changing their process such that you’re now interviewing for a specific team at the outset, but the broader point still stands). So now if Meta is about to make you an offer, they can set an artificially fast expiration date to run out the clock. Though you started in a strong position with multiple interviews, including at companies that are known to pay well, you’ve now weakened that position by sharing details. Here’s another thing that could happen in this scenario. Let’s say that it’s the same set of companies as above, but this time you’re talking to the recruiter from startup A. The recruiter asks you where else you’re interviewing. If you mention that you’re interviewing at both Google and Meta, they might get spooked. I’ve seen this happen a bunch. Dropping FAANG names can be a good power move, or it can shoot you in the foot, and which it’ll be really depends on the situation. Many small startups view FAANG candidates as risky because they know they can’t compete on comp and are worried that you’re going to walk the moment that you get a FAANG offer. This may or may not be true (not everyone is motivated just by comp!), but it’s not to your advantage to reveal it. YOU should be in control of if and when we play the FAANG card. Example #2: You’re interviewing at one company and are also up for a promotion Here’s a different example. Let’s say that you work at a startup, and you’re up for a promotion soon. You figured it’d make sense to see what’s out there as well, so you’ve started interviewing with another startup. Your recruiter asks you in your first call about where else you’re interviewing and what your comp expectations are. You may be tempted to mention that you’re up for a promotion because that feels like it’ll give you leverage — if you get a promotion, the startup will have to work harder to entice you to leave, after all. Not so fast! If you mention that you’re up for a promotion: Your recruiter will start checking in consistently on whether you got it. Promotions always take longer than you think, and the increase in your comp may not be what you expect. At some point, if you haven’t gotten it yet, the recruiter will assume it’s not coming, and then you actually lose leverage because they know that you’re going to be more likely to walk. If you mention that you’re not interviewing anywhere else, that’s just a giveaway that you have no leverage: Promotion or not, many of our users assume that they have leverage because, “I don’t have to leave my job, so my current job is leverage.” That’s not true, though — even in this climate, and definitely in a hiring boom, an engineer having another job is table stakes. Almost every candidate you’re competing with will be currently employed. So even if having a job gives you a little bit of leverage, it gets canceled out when everyone has the same exact thing. The details may differ in your case, but the fundamental mechanics are the same. When you reveal information before you know what hand you’ve been dealt, it can only hurt you. I’m struggling to think of a scenario where revealing something has been beneficial. I suppose the one exception to revealing information is this: Sometimes it can be useful to give your recruiter a rough estimate for when you’ll be collecting offers, e.g., “I’ve just started interviewing. I expect to get through all my interviews and onsites in the next 6 weeks and start collecting offers 2 months from now. Does that timeline work for you?” This technique can be helpful for aligning expectations up front and then keeping recruiters off your back, as they won’t need to chronically text you to make sure you haven’t taken another offer yet (we’ll talk more about texting with recruiters in the next section). But note that even in this example, we’re not actually revealing any information about where you’re interviewing, how long it’s taking, or compensation. You’re just setting a timeline based on hypotheticals without giving out any details that can be used against you later. When you share the actual timeline you’re working with, you no longer control the timing of your job search, and a huge part of negotiation is controlling timing so you can make all your offers come in at the same time. Mistake #2: Premature negotiation “Don't fire until you see the whites of their eyes!” -Unknown officer at the Battle of Bunker Hill Just like not revealing information too early, you also want to avoid negotiating too early. They’re two sides of the same coin. Think of it like a hand of cards. At the beginning, you have no idea what you’re going to draw. The longer you wait to negotiate, assuming you’ve timed things correctly, the more information you have. Then, when you’re ready to negotiate, you can look at your hand and selectively share information that puts you in the strongest position. For instance, if you have a high base salary from one company, a great equity package from a public company, and a signing bonus from a third company, you can strategically share those portions of the offers without sharing the weaker parts. Each negotiation is different, and it’s hard to give catch-all advice, but that’s generally the situation you should set yourself up to be in. With that in mind, I’m a firm believer in negotiating when you’re ready and not before. Until you know what else is on the table, it’s really hard to 1) have the bravado that comes with actually having multiple offers (this is possible to fake, but trust me, it’s hard) and 2) negotiate effectively — you will never know as well as your recruiter what salary bands are like, what market comp is, and so on. They do this all day. This may be your first or fifth time doing it, but there’s massive experience and information asymmetry. There are two ways to combat this power imbalance: have as many of your interactions be asynchronous as possible (we discussed that earlier) and do everything you can to negotiate when you’re at the point of maximum information, and not before. Daniel Biales, one of our former negotiation clients, explained the latter really well. When I received a low offer, my first inclination was to start the negotiating process. Aline helped me to realize that this was not the best course of action. The problem with this approach is that I wanted to start negotiating before receiving my highest offer. If I negotiated an increase then, I would have had to renegotiate when I received the higher offer. This will cause negotiating fatigue for you and the company. They will be less likely to negotiate a second time because they don’t know how many times you will ask them for more. First, focus on strategies to draw out your decision. Then, when you have all your offers, start negotiating. There may be a couple of back and forth communications, but they will be over a short time span rather than drawn out. Example #1 revisited: You're interviewing at Google, Meta, and two startups Let’s review our first example again. Imagine that you’re interviewing at Google, Meta, and two startups, A and B, just like before. Startup A makes you an offer: $160k base, 0.1% of the company in options over four years, no signing bonus. You react to it and say that you were hoping for a signing bonus. The recruiter comes back with a $10k signing bonus quickly and pressures you to make a decision, saying that they have other candidates waiting. By starting to negotiate, you accelerated their timeline, and this is going to make it hard to go back and ask for more signing bonus. You try to stall, and then a few days later, Google makes you an offer that includes a $25k signing bonus. You’re still excited about the startup for reasons other than compensation, but now you have to go back to them and say that you actually got a $25k signing bonus at Google. They are unlikely to move again. So, don’t negotiate until you’re ready. It’s hard to walk things back. That doesn’t mean it’s not possible to negotiate in stages and gradually start bringing up all your offers. In my experience, however, this is a much more difficult maneuver, takes way more experience, is much more stressful for the candidate, and often ends up with the same results as laying a solid foundation and just negotiating once at the end. So what do you say when you get asked pointed questions by your recruiter about your comp expectations or where you’re interviewing? And how do you delay negotiation until you’re ready? How to handle recruiter calls: “passive information gathering” mode Until you’re ready to negotiate, your default mode should be “passive information gathering.” This means that you listen rather than talk. I coach all of our negotiation clients to be in this mode when they get on a call with a recruiter. Be polite and gracious to a fault. If it’s an offer call, thank them for the work they did to put your offer together and for advocating for you. If it’s earlier in the process, thank them for their help so far. Express genuine enthusiasm. If it’s an early call, express excitement about the company or the interview process if there’s something idiosyncratically cool about it. If it’s an offer call, express excitement for the team, the projects, the hiring manager, whatever it is. And be genuine. Every offer will have something exciting about it. If the recruiter is making an offer, do not react to what you’re being told beyond expressing enthusiasm. Say that you need some time to process and/or talk to your {family, partner, spouse}. Why should you not react? Because recruiters do this a lot, and you don’t. Negotiating on the phone on the fly is really hard. You’re going to need time to think, and you need a way to level the playing field. Email is the great leveler in these interactions because it’s asynchronous, and it gives you time to think and plan. No one is realistically expecting you to react to major life decisions on the fly! Use email (not phone when possible and DEFINITELY not texts) to interact with recruiters. We strongly advise you to leave your phone number off your resume, and if you have to fill in any required phone number fields while applying, to put a Google voice number. Also, in your first conversation with your recruiter, let them know that you are very bad at using the phone and strongly prefer email. Finally, whenever they text or call, wait a few hours, and answer with email and remind them that email is the best way to reach you (you can always say that you don’t have notifications enabled during work hours). Why does all of this matter? Phone calls are extremely disruptive, as are texts. The only way to level the playing field in negotiation is to have time to think and to possibly ask for advice. In particular, the casual nature of texting lulls you into a false sense of security. Moreover, the fact that texts or phone calls interrupt you from something else puts you at a disadvantage — when you get interrupted, your instinct is to quickly respond to make the interruption go away. But knee-jerk responses are rarely the right ones, and you’ll find yourself giving away information you shouldn’t have. You will have to get on the phone eventually, of course, but you never have to text. If a recruiter asks you pointed questions about comp expectations or where else you’re interviewing, refer to the section called “Exactly what to say” right below! Exactly what to say In all the snippets below, you’ll notice that they end with the same sentence: I promise not to accept other offers until I have a chance to discuss them with you. This is deliberate, and it’s there because it’s disarming. Fundamentally, recruiters ask you all of these questions because they don’t want to lose out on you and have you go to another company. If you can speak to that worry head-on, there’s not much they can say back. For questions about comp expectations at the beginning of the process: At this point, I don’t feel equipped to throw out a number because I’d like to find out more about the opportunity first – right now, I simply don’t have the data to be able to say something concrete. If you end up making me an offer, I would be more than happy to iterate on it if needed and figure out something that works. I promise not to accept other offers until I have a chance to discuss them with you. For questions about comp expectations at the end of the process: It sounds like there’s an offer coming, and I’m really excited about it. I’m not sure exactly what number I’m looking for, but if you’d be able to share what an offer package might look like, then I will gladly iterate on it with you if needed and figure out something that works. I promise not to accept other offers until I have a chance to discuss them with you. For questions about where else you’re interviewing at the beginning of the process: I’m currently speaking with a few other companies and am at various stages with them. I’ll let you know if I get to the point where I have an exploding offer, and I promise not to accept other offers until I have a chance to discuss them with you. For questions about where else you’re interviewing at the end of the process: I’m wrapping things up with a few companies and in process with a few more. I promise to keep you in the loop, and I promise not to accept other offers until I have a chance to discuss them with you. For when a recruiter provides you a salary range and asks you to comment on it, at the beginning of the process: Thank you for sharing that with me. Right now I don’t know enough about the opportunity to value it concretely, and I honestly haven't done my market research. If you end up making me an offer, I would be more than happy to iterate on it if needed and figure out something that works. I promise not to accept other offers until I have a chance to discuss them with you. For when a recruiter provides you a salary range and asks you to comment on it, at the end of the process: Thank you for sharing that with me. I haven't done my research, so I am unable to comment on that range. However, if you do make me an offer, I promise to iterate on it if needed and figure out something that works. I promise not to accept other offers until I have a chance to discuss them with you. Conclusion I said it in the beginning, and I’ll say it again. Negotiation isn’t about saying the right thing. It’s about laying a foundation: not revealing anything until you’re ready to negotiate, not negotiating too early, and making sure that you’ve set yourself up to have multiple offers. Then, once those offers come in, you swoop in with sharp precision, negotiate once (possibly with just your top choice company), and be done with it. If you’ve set yourself up for success, done the foundational work, and haven’t made the mistakes in this post, the negotiation will feel like a foregone conclusion. If you need some hands-on help navigating salary negotiation, sign up for our salary negotiation package. You don't pay anything unless you get more, and we’ll be with you every step of the way, for every recruiter call, every email you need ghostwritten, and every strategy discussion. Unlimited sessions, unlimited help, whatever we need to do to get you results.Life is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedRelated postsThe unwritten rules (till now) of negotiating with MetaExactly what to say when recruiters ask you to name the first number… and other negotiation word-for-wordsAre recruiters better than a coin flip at judging resumes? Here's the data.How to get in the door at top companies: cold outreach to hiring managers. Part 2 of 2.Stuff we write aboutRecessionSalary negotiationCompany NewsData Deep DivesDiversityGuest PostsHiring is brokenInterview tipsFor employers, how to hire betterHave interviews coming up? Study up on common questions and topics.MEDIUMData Structures and AlgorithmsShuffle StringWrite a function that takes a string as an input and returns a shuffled version of that string then write another function to analyze how well it was shuffled. MEDIUMData Structures and AlgorithmsSubarray Sum Equals KGiven an unsorted array of integers and an integer k, find the number of subarrays whose sum equals k.MEDIUMData Structures and AlgorithmsPartition to K Equal Sum SubsetsGiven an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.RecursionQuestions & tipsQueuesQuestions & tipsLinked ListsQuestions & tipsSystem DesignQuestions & tipsBinary SearchQuestions & tipsBinary TreesQuestions & tipsWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/blog/sabotage-salary-negotiation-before-even-start",
          "author": "",
          "user_id": ""
        },
        {
          "title": "How to Solve Three Sum",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryLearning CenterQuestionsThree SumTable of ContentsIntroductionAnalysisSolutionsBrowse all interview replaysLife is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedMEDIUMDATA STRUCTURES AND ALGORITHMSHow to Solve Three SumHASH MAPSSEARCHARRAYSSORTINGHASH TABLESWritten ByTom WagnerTom has four years of experience developing software professionally, including experience at both Amazon and Pinterest. He is experienced both as an interviewer, conducting interviews on behalf of the companies he's worked for, and interviewee, as he has landed software engineering offers from Google, Twitter, Stripe, Airtable and Doordash during previous job searches.Kenny PolyakKenny is a software engineer and technical leader with four years of professional experience spanning Amazon, Wayfair, and U.S. Digital Response. He has taught courses on Data Structures and Algorithms at Galvanize, helping over 30 students land new software engineering roles across the industry, and has personally received offers from Google, Square, and TikTok.Three Sum IntroductionThe Three Sum problem involves finding all unique triplets of numbers in an array that sum up to a given target. As an extension of the classic Two Sum problem, it can be solved efficiently by building on top of that problem and applying a variety of sorting and hashing approaches.Three Sum ProblemGiven an array of integers, return an array of triplets (in any order) such that i != j != k and nums\\[i\\] + nums\\[j\\] + nums\\[k\\] = 0. Note that the solution set must not include duplicate triplets (i.e., \\[1, 0, 0\\] and \\[0, 1, 0\\] are duplicative). Example Inputs and Outputs Example 1 Input: \\[-1,0,1,2,-1,-4\\] Output: \\[\\[-1,-1,2\\],\\[-1,0,1\\]\\] Example 2 Input: \\[1,2,7,12\\] Output: \\[\\] Example 3 Input: \\[7,4,-7,0\\] Output: \\[\\[0,-7,7\\]\\], OR \\[\\[7,-7,0\\]\\], etc.Three Sum SolutionsThis problem is a continuation of a similar problem aptly-named \"Two Sum\" in which the premise is very similar. As with that problem, for Three Sum there are naive, combination-driven approaches as well as more-efficient approaches. 1. Brute Force When approaching an algorithms problem, particularly when thinking about the brute force approach, it is often easiest to start by thinking about how you would solve a given problem if you were to solve it by hand. Take Example 3, \\[7, 4, -7, 0\\]. While the answer for this example input may be obvious by simply looking at the array and thinking about the problem, you could also solve it by generating all the possible triplet combinations and evaluating which triplets meet the required criteria A + B + C = 0. Input: \\[7,4,-7,0\\] Triplets: \\[\\[7, 4, -7\\], \\[7, 4, 0\\], \\[7, -7, 0\\], \\[4, -7, 0\\]\\] Now the task becomes how we can generate the above list of triplets using code. For brute-force combinations problems the answer is often nested for loops, and given we are generating a list of triplets (vs. pairs or quadruplets) we can utilize three nested for loops to generate our list of triplets. From there we can scan the list and check whether each triplet meets our requirement of summing to zero. The \"no duplicates\" requirement adds a bit of complexity. If we were to utilize three for loops, there would be no way to eliminate duplicates and thus it would be impossible to find a valid solution; however, we can tackle this by sorting the triplet before saving it to a hash map using a stringified-triplet as the key. Three Sum Python and JavaScript Solutions - Brute ForcePythonJavaScriptJavadef threeSum(nums: List\\[int\\]) -> List\\[List\\[int\\]\\]: three\\_sums = {} for i in range(0, len(nums)): for j in range(i+1, len(nums)): for k in range(j+1, len(nums)): if nums\\[i\\] + nums\\[j\\] + nums\\[k\\] == 0: sorted\\_answer = sorted(\\[nums\\[i\\], nums\\[j\\], nums\\[k\\]\\]) three\\_sums\\[str(sorted\\_answer)\\] = \\[nums\\[i\\], nums\\[j\\], nums\\[k\\]\\] return three\\_sums.values()1def threeSum(nums: List\\[int\\]) -> List\\[List\\[int\\]\\]: 2 three\\_sums = {} 3 for i in range(0, len(nums)): 4 for j in range(i+1, len(nums)): 5 for k in range(j+1, len(nums)): 6 if nums\\[i\\] + nums\\[j\\] + nums\\[k\\] == 0: 7 sorted\\_answer = sorted(\\[nums\\[i\\], nums\\[j\\], nums\\[k\\]\\]) 8 three\\_sums\\[str(sorted\\_answer)\\] = \\[nums\\[i\\], nums\\[j\\], nums\\[k\\]\\] 9 return three\\_sums.values()Time/Space Complexity Time Complexity: O(n³) Space Complexity: O(len(answer)) (space complexity will scale in line with the number of triplets found) 2. Two Sum Hashmap Now that we've solved the problem using a brute-force, combinations driven approach let's think about how we can leverage common data structures to find a more efficient solution. Thinking back to the Two Sum problem described earlier, consider the following nums array and target value: nums = \\[1, 7, 12, 4\\], target= 19. If we are iterating over this list (\\[1, 7, 12, 4\\]) and on the 0th index, our current value is 1. Therefore, in order to sum to our target of 19, we are looking for 18. From an algebra perspective we know this because if X + 1 = 19, so X = 19 - 1. From here, the naive approach would be to scan the list looking for 18, however we can leverage a data structure that allows for constant time lookups (namely, a set or hashmap) in order to avoid repeatedly scanning the list. To translate the above logic to code, our Two Sum algorithm (which is relevant to Three Sum, I promise) looks like this:Python# Prompt: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. def twoSum(self, nums: List\\[int\\], target: int) -> List\\[int\\]: nums\\_dict = {val: idx for idx, val in enumerate(nums)} for idx, val in enumerate(nums): looking\\_for = target - val if looking\\_for in nums\\_dict and nums\\_dict\\[looking\\_for\\] != idx: return \\[idx, nums\\_dict\\[looking\\_for\\]\\]1# Prompt: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. 2def twoSum(self, nums: List\\[int\\], target: int) -> List\\[int\\]: 3 nums\\_dict = {val: idx for idx, val in enumerate(nums)} 4 for idx, val in enumerate(nums): 5 looking\\_for = target - val 6 if looking\\_for in nums\\_dict and nums\\_dict\\[looking\\_for\\] != idx: 7 return \\[idx, nums\\_dict\\[looking\\_for\\]\\]With that idea in mind, we can turn our attention back to Three Sum and consider how we can use a similar approach to solve the problem at hand. In this case, we can generate a hashmap that contains all two-item combinations in the array keyed by the sum of those two items, then use that hashmap to determine which tuples can be combined with any item in the array to sum to 0 (roughly, sum(Tuple\\[X, Y\\]) + otherIntegerZ == 0). Three Sum Python and JavaScript Solutions - Two Sum HashmapPythonJavaScriptJavafrom collections import defaultdict, Counter def twoSumsMap(nums: List\\[int\\]) -> Dict\\[int, Tuple\\[int, int\\]\\]: two\\_sums\\_map = defaultdict(set) for i, val\\_one in enumerate(nums): for j, val\\_two in enumerate(nums\\[i+1:\\]): two\\_sums\\_map\\[val\\_one + val\\_two\\].add( (val\\_one, val\\_two) if val\\_one <= val\\_two else (val\\_two, val\\_one) ) return two\\_sums\\_map def threeSum(nums: List\\[int\\]) -> List\\[List\\[int\\]\\]: # O(n^2) two\\_sums\\_map = self.twoSumsMap(nums) # O(n) counter\\_for\\_nums = Counter(nums) three\\_sums = {} # iterating on the dictionary instead of \\`nums\\` in order to avoid duplicative work for curr\\_val in counter\\_for\\_nums.keys(): two\\_sum\\_tuples\\_for\\_val = two\\_sums\\_map\\[-curr\\_val\\] for val\\_one, val\\_two in two\\_sum\\_tuples\\_for\\_val: if (curr\\_val != val\\_one and curr\\_val != val\\_two) or counter\\_for\\_nums\\[curr\\_val\\] >= 3: sorted\\_vals = sorted(\\[curr\\_val, val\\_one, val\\_two\\]) three\\_sums\\[str(sorted\\_vals)\\] = sorted\\_vals return three\\_sums.values()1from collections import defaultdict, Counter 2def twoSumsMap(nums: List\\[int\\]) -> Dict\\[int, Tuple\\[int, int\\]\\]: 3 two\\_sums\\_map = defaultdict(set) 4 for i, val\\_one in enumerate(nums): 5 for j, val\\_two in enumerate(nums\\[i+1:\\]): 6 two\\_sums\\_map\\[val\\_one + val\\_two\\].add( 7 (val\\_one, val\\_two) 8 if val\\_one <= val\\_two else 9 (val\\_two, val\\_one) 10 ) 11 return two\\_sums\\_map 12def threeSum(nums: List\\[int\\]) -> List\\[List\\[int\\]\\]: 13 # O(n^2) 14 two\\_sums\\_map = self.twoSumsMap(nums) 15 # O(n) 16 counter\\_for\\_nums = Counter(nums) 17 three\\_sums = {} 18 # iterating on the dictionary instead of \\`nums\\` in order to avoid duplicative work 19 for curr\\_val in counter\\_for\\_nums.keys(): 20 two\\_sum\\_tuples\\_for\\_val = two\\_sums\\_map\\[-curr\\_val\\] 21 for val\\_one, val\\_two in two\\_sum\\_tuples\\_for\\_val: 22 if (curr\\_val != val\\_one and curr\\_val != val\\_two) or counter\\_for\\_nums\\[curr\\_val\\] >= 3: 23 sorted\\_vals = sorted(\\[curr\\_val, val\\_one, val\\_two\\]) 24 three\\_sums\\[str(sorted\\_vals)\\] = sorted\\_vals 25 return three\\_sums.values()Time/Space Complexity Time Complexity: O(n²) Space Complexity: O(n²) 3. Sorting, Iterating and Two Point When given a list of strings or numbers during an algorithms interview we should always pause to consider whether sorting the input would allow the problem to be solved in a more efficient way, and in this case the answer is yes. Consider the following array: \\[-2, 3, 1, 7, -4, 9\\] And the same array sorted: \\[-4, -2, 1, 3, 7, 9\\] When iterating over an array we should also pause to consider whether adding a second pointer, known as the \"two pointers\" approach, would be helpful. In this case we can design an algorithm that combines both of the approaches above. We first sort the array, then iterate over it (index I), placing two pointers (L and R) at the beginning and end of the other already-sorted numbers. To iterate the two pointers, we can conditionally moving either the left or right pointer based on whether the current triplet sum is larger or smaller than zero. If at any point arr\\[I\\] + arr\\[L\\] + arr\\[R\\] = 0 that means we have found a triplet that sums to zero.Plaintext I L R \\[-4, -2, 1, 3, 7, 9\\] arr\\[I\\] (-4) + arr\\[L\\] (-2) + arr\\[R\\] (9) = 3, which is >= 0 --> move right pointer I L R \\[-4, -2, 1, 3, 7, 9\\] arr\\[I\\] (-4) + arr\\[L\\] (-2) + arr\\[R\\] (7) = 1, which is >= 0 --> move right pointer again I L R \\[-4, -2, 1, 3, 7, 9\\] arr\\[I\\] (-4) + arr\\[L\\] (-2) + arr\\[R\\] (3) = -3, which is <= 0 --> move left pointer I L R \\[-4, -2, 1, 3, 7, 9\\] arr\\[I\\] (-4) + arr\\[L\\] (1) + arr\\[R\\] (3) = 0, we found a match! Then move left pointer I LR \\[-4, -2, 1, 3, 7, 9\\] L = R, while loop no longer true, iterate \\`I\\` I L R \\[-4, -2, 1, 3, 7, 9\\] arr\\[I\\] (-2) + arr\\[L\\] (3) + arr\\[R\\] (9) = 10, which is >= 0 --> move right pointer etc.1 I L R 2\\[-4, -2, 1, 3, 7, 9\\] arr\\[I\\] (-4) + arr\\[L\\] (-2) + arr\\[R\\] (9) = 3, which is >= 0 --> move right pointer 3 I L R 4\\[-4, -2, 1, 3, 7, 9\\] arr\\[I\\] (-4) + arr\\[L\\] (-2) + arr\\[R\\] (7) = 1, which is >= 0 --> move right pointer again 5 I L R 6\\[-4, -2, 1, 3, 7, 9\\] arr\\[I\\] (-4) + arr\\[L\\] (-2) + arr\\[R\\] (3) = -3, which is <= 0 --> move left pointer 7 I L R 8\\[-4, -2, 1, 3, 7, 9\\] arr\\[I\\] (-4) + arr\\[L\\] (1) + arr\\[R\\] (3) = 0, we found a match! Then move left pointer 9I LR 10\\[-4, -2, 1, 3, 7, 9\\] L = R, while loop no longer true, iterate \\`I\\` 11 I L R 12\\[-4, -2, 1, 3, 7, 9\\] arr\\[I\\] (-2) + arr\\[L\\] (3) + arr\\[R\\] (9) = 10, which is >= 0 --> move right pointer 13etc.Three Sum Python and JavaScript Solutions - Two Sum HashmapPythonJavaScriptJavadef threeSum(self, nums: List\\[int\\]) -> List\\[List\\[int\\]\\]: sorted\\_nums = sorted(nums) three\\_sums = \\[\\] for i in range(len(sorted\\_nums)): # avoid duplicates if i > 0 and sorted\\_nums\\[i\\] == sorted\\_nums\\[i - 1\\]: continue target = -sorted\\_nums\\[i\\] l, r = i + 1, len(sorted\\_nums) - 1 while l < r: if sorted\\_nums\\[l\\] + sorted\\_nums\\[r\\] == target: three\\_sums.append(\\[sorted\\_nums\\[i\\], sorted\\_nums\\[l\\], sorted\\_nums\\[r\\]\\]) l += 1 # avoid duplicates again while l < r and sorted\\_nums\\[l\\] == sorted\\_nums\\[l - 1\\]: l += 1 elif sorted\\_nums\\[l\\] + sorted\\_nums\\[r\\] < target: l += 1 else: r -= 1 return three\\_sums1def threeSum(self, nums: List\\[int\\]) -> List\\[List\\[int\\]\\]: 2 sorted\\_nums = sorted(nums) 3 three\\_sums = \\[\\] 4 for i in range(len(sorted\\_nums)): 5 # avoid duplicates 6 if i > 0 and sorted\\_nums\\[i\\] == sorted\\_nums\\[i - 1\\]: 7 continue 8 target = -sorted\\_nums\\[i\\] 9 l, r = i + 1, len(sorted\\_nums) - 1 10 while l < r: 11 if sorted\\_nums\\[l\\] + sorted\\_nums\\[r\\] == target: 12 three\\_sums.append(\\[sorted\\_nums\\[i\\], sorted\\_nums\\[l\\], sorted\\_nums\\[r\\]\\]) 13 l += 1 14 # avoid duplicates again 15 while l < r and sorted\\_nums\\[l\\] == sorted\\_nums\\[l - 1\\]: 16 l += 1 17 elif sorted\\_nums\\[l\\] + sorted\\_nums\\[r\\] < target: 18 l += 1 19 else: 20 r -= 1 21 return three\\_sumsTime/Space Complexity Time Complexity: O(n²) Space Complexity: O(n) (or O(1) if sorted in-place) Practice the Three Sum Problem With Our AI InterviewerStart AI InterviewWatch These Related Mock InterviewsFireEye InterviewerThree sumWarp Dromedary, a FireEye engineer, interviewed in JavaWatch interviewAmazon InterviewerClosest Three SumHot Gyro, an Amazon engineer, interviewed in PythonWatch interviewAbout interviewing.iointerviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.Sign up for a mock interviewWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/questions/three-sum",
          "author": "",
          "user_id": ""
        },
        {
          "title": "How to Solve Distributed Databases",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryLearning CenterQuestionsDistributed DatabasesTable of ContentsIntroductionAnalysisSolutionsBrowse all interview replaysLife is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedMEDIUMSYSTEM DESIGNHow to Solve Distributed DatabasesSYSTEM DESIGNWritten ByAdam BhulaWhat Is The Distributed Databases Problem?The Distributed Databases Problem provides us with a scenario in which we have an SQL database and asks us to create a solution that allows us to add more machines once the first has reached capacity. In simple terms we must find a way to distribute this database. The caveat to this is that we do not have access to any automated tools for distributing. This problem demands consideration for the bottlenecks that may occur while manually distributing a SQL database.An Example of the Distributed Databases ProblemHow would you organize a SQL database like MySQL such that you can add more machines once your current ones reach maximum capacity? With the limitation that you do not have access to any automated tools for distributing.How to Solve the Distributed Databases ProblemTo handle the increasing capacity in our SQL-based database system without relying on automated distributing tools, we can take a manual sharding approach. This means we'll manually divide the data across multiple machines or servers, allowing us to scale the system and add more machines when needed. SQL Databases Let’s start by talking about SQL databases: SQL guarantees atomicity and isolation of transactions. SQL seamlessly supports multi-table queries (JOINs). SQL optimizes both indexes and queries on the DB level. Before we go further, let’s clarify the functional requirements for this problem. Making an RDMBS (a relational database management system, the generalization of the loose term “SQL database”) horizontally scalable is, in general, a next-to-impossible task. For the purposes of scoping this \\[interview\\] conversation, let’s agree what we should focus on, and what can be left outside the spotlight. Specifically, there are several optimization directions: Scale to support more data volume (capacity), Scale to support more query throughput (TPS, transactions per second), Scale to support faster queries (tail latency), and Scale to enable broad cross-shard complex queries with JOINs and other cross-shard data transfer. Option #4 is the holy grail, which we’d rather not touch today. Let’s assume, for this 45-minute discussion, that most high-throughput / low-latency queries only need to access the data that lives on one shard. The queries that require the data from multiple shards are allowed to be slow. (A useful exception: if some small amount of metadata exists, we can keep this data copied on every single shard, duplicated N times.) So let’s focus on #1 while considering the original problem statement of “you can add more machines once your current ones reach maximum capacity”. Sharding the database Next, the question is: how do we go about sharding our database? First, we have to identify the sharding key. We’ll choose a column or attribute in our table that can act as a sharding key. This key can help to evenly distribute the data across multiple machines if we can assume even load. In situations where performance is a consideration and we have a key that is hit more often than others, we may need special considerations to distribute the data unevenly to instead even out the load. Common examples include things such as user IDs. For this question we aren’t given any information about the data we have, but it may be worthwhile to ask for this information from your interviewer. Once we have identified the sharding key, we can employ consistent hashing as our sharding technique. Consistent hashing ensures that the distribution of data across shards is balanced and minimizes the amount of data that needs to be remapped when adding or removing machines from the system. With consistent hashing, we can achieve a scalable sharding strategy that can handle the increasing data volume. When it comes to partitioning the data, we can split it based on our sharding key among the different machines in the network. Each machine will be responsible for storing a specific range or subset of data based on the sharding key value. Keep in mind that we’ll have to adjust our SQL queries to include the sharding key in the WHERE clause. This ensures that the queries are routed to the appropriate machine holding the relevant data. Now that we’ve determined the sharding strategy, we'll set up multiple instances of the SQL database, each running on a separate machine. Each instance will be responsible for storing and serving a specific shard of the data. We'll configure our application to interact with the appropriate database instance based on the shard key/criteria we used for sharding. Load Balancer To ensure the requests hit the correct shards, we introduce a load balancer into the system architecture. The load balancer acts as a traffic controller, receiving incoming requests and routing them to the correct database shards. In addition to routing the traffic correctly, if our consistent hashing approach keeps each data element on more than one shard, the load balancer can balance the load over these shards, thus evening the load and improving top-line performance. Indexing Even in a system with a distributed SQL database, optimizing query performance is still vital. We'll create appropriate indexes in our database schema to improve search and retrieval efficiency. As long as the requested data lives within one shard, a local DB index on this shard would improve query performance (e.g., looking for my WhatsApp messages to my friend Dima from July 2017, as long as the DB of messages is sharded by sender ID). For cross-shard queries, however, we will need far more sophisticated, custom, outside-the-DB indexes. But what do we mean by indexing? In the context of an individual database (a single shard in our current design), indexing is the process of creating a data structure that enhances the speed and efficiency of data retrieval operations. An index is essentially a separate data structure that may contain a sorted copy of specific data fields, and/or reference these fields in other ways, which allows for faster lookup and retrieval of information. What about \"indexing” the sharding key? Well, that’s a little different. Logically, it does mean creating an index specifically on the column or attribute that is used as the sharding key in a sharded database setup. But we already decided to use consistent hashing for shard selection. So, yes, it is a custom data structure, but it is not a database index that maps the sharding key values to the corresponding shard or machine; it’s “the ring” of the consistent hashing. This “ring” data structure enables the load balancer to quickly determine the location of the data based on the sharding key value, which improves the efficiency of data retrieval operations and effectively acts as the index on this “column,” despite living outside the very DB realm, but rather inside the load balancers. Here’s an example: if the sharding key is the user ID, and we want to retrieve all the data related to a specific user, querying the database using the user ID as a filter would be faster with the indexing in place. This allows the database system to quickly locate the shard or machine where the data for that user is stored, reducing the number of network requests and tail latency. In summary, indexing the sharding key involves creating a separate data structure that helps optimize the process of locating and retrieving data stored in specific shards or machines based on the sharding key value. Benefits How does this benefit us? Realistically, this is a fairly advanced topic, as it will come into play once we are talking about cross-shard data retrieval. Indexing the sharding key in a sharded database setup primarily improves the performance of SELECT statements, specifically those that involve filtering or searching based on the sharding key. These select statements benefit from the index by enabling faster data retrieval from the relevant shards or machines. Note that, in a simple version, making use of this newly created index would require the user to write their SELECT statements while keeping in mind the very fact that the data is sharded; an “automagical” SQL query engine that runs queries cross-shards as needed is a far more complex problem for this margin to contain. However, indexing the sharding key may not have a direct impact on the speed of UPDATE or MERGE statements. UPDATE and MERGE statements typically involve modifying or merging existing data rather than searching or filtering based on the sharding key. The performance of update and merge operations in a sharded database is more influenced by factors such as network latency, data synchronization, and other factors pertaining to the underlying database management system. Our design approach might be different if our optimization criteria had been to allow for faster data querying; since we are optimizing for capacity, however, the above should be good enough. While this manual sharding approach requires more effort and management compared to automated distributing tools, it gives us flexibility and control over our database infrastructure. We can scale the system by adding more machines (up to a certain point) while still benefiting from the advantages of a SQL-based database. It’s important to note that the critical mass for this is quite low; after just a dozen or so machines simply adding more instances may very well slow the whole system down, not speed it up. To resolve this, we have DBAs to not just add machines but understand exactly what the query patterns are, configure load, and manual sharding to keep the data local for the most expensive and/or most frequent queries.Watch These Related Mock InterviewsGoogle InterviewerDistributed databasesIntergalactic Avenger, a Google engineer, interviewed Watch interviewAbout interviewing.iointerviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.Sign up for a mock interviewWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/questions/distributed-databases",
          "author": "",
          "user_id": ""
        },
        {
          "title": "How to Solve Intersection of Linked List",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryLearning CenterQuestionsIntersection of Linked ListTable of ContentsIntroductionAnalysisSolutionsBrowse all interview replaysLife is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedEASYDATA STRUCTURES AND ALGORITHMSHow to Solve Intersection of Linked ListLINKED LISTSTWO POINTERSWritten ByAdam BhulaIntersection of Linked List IntroductionThe Intersection of linked list problem (also known as the Intersection of two linked list problem) asks us to return the node at which two linked lists intersect, if none then we return None. This problem requires us to consider the lengths of the given linked lists before using our pointers. Using the lengths we can adjust our starting positions accordingly. By using these two pointers effectively to traverse the lists we can find the point in which they intersect without comparing every node.Intersection of Linked List ProblemGiven the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return none.Intersection of Linked List SolutionsWe can solve this problem using two-pointers. We start by finding the lengths of the two linked lists and adjust the starting positions of the pointers accordingly. This step ensures that both pointers are at the same relative position from the end of their respective lists. Next, we traverse the linked lists simultaneously using the two pointers. We keep moving the pointers one node at a time until either they meet at an intersection point or both reach the end of their lists. By doing this, we can search for the intersection point without having to compare every node. If the pointers meet, it means we have found the intersection point. We can return that node as the result. If the pointers reach the end of their lists without meeting, it let's us know that there is no intersection between the two linked lists. In this case, we return 'None' to signify the absence of an intersection.PythonJavaScriptJavaclass ListNode: def \\_\\_init\\_\\_(self, val=0, next=None): self.val = val self.next = next def getIntersectionNode(headA, headB): # Check if either list is empty if not headA or not headB: return None # Get the lengths of both lists lenA, lenB = 0, 0 nodeA, nodeB = headA, headB while nodeA: lenA += 1 nodeA = nodeA.next while nodeB: lenB += 1 nodeB = nodeB.next # Move the longer list's head pointer to align the lengths while lenA > lenB: headA = headA.next lenA -= 1 while lenB > lenA: headB = headB.next lenB -= 1 # Traverse both lists to find the intersection point while headA != headB: headA = headA.next headB = headB.next # Return the intersection node (or None if no intersection) return headA # Create linked lists for testing # Intersection point at node with value 8 common = ListNode(8, ListNode(4, ListNode(5))) headA = ListNode(4, ListNode(1, common)) headB = ListNode(5, ListNode(6, ListNode(1, common))) # Test our solution intersection = getIntersectionNode(headA, headB) if intersection: print(\"Intersection at node with value:\", intersection.val) else: print(\"No intersection\") #Expected output: 81class ListNode: 2 def \\_\\_init\\_\\_(self, val=0, next=None): 3 self.val = val 4 self.next = next 5 6def getIntersectionNode(headA, headB): 7 # Check if either list is empty 8 if not headA or not headB: 9 return None 10 11 # Get the lengths of both lists 12 lenA, lenB = 0, 0 13 nodeA, nodeB = headA, headB 14 while nodeA: 15 lenA += 1 16 nodeA = nodeA.next 17 while nodeB: 18 lenB += 1 19 nodeB = nodeB.next 20 21 # Move the longer list's head pointer to align the lengths 22 while lenA > lenB: 23 headA = headA.next 24 lenA -= 1 25 while lenB > lenA: 26 headB = headB.next 27 lenB -= 1 28 29 # Traverse both lists to find the intersection point 30 while headA != headB: 31 headA = headA.next 32 headB = headB.next 33 34 # Return the intersection node (or None if no intersection) 35 return headA 36 37# Create linked lists for testing 38# Intersection point at node with value 8 39common = ListNode(8, ListNode(4, ListNode(5))) 40headA = ListNode(4, ListNode(1, common)) 41headB = ListNode(5, ListNode(6, ListNode(1, common))) 42 43# Test our solution 44intersection = getIntersectionNode(headA, headB) 45if intersection: 46 print(\"Intersection at node with value:\", intersection.val) 47else: 48 print(\"No intersection\") 49 50#Expected output: 8Time/Space Complexity Analysis Time Complexity: O(m + n), where m and n are the lengths of the two linked lists. We need to traverse both lists to calculate their lengths and then traverse them again simultaneously until we find the intersection point or reach the end. This means that the time complexity is linear with respect to the lengths of the lists. Space Complexity: O(1), as we only use a constant amount of extra space to store the two pointers and a few other variables. Watch These Related Mock InterviewsVMware InterviewerLinked list intersectionThe Masked Hedgehog, a VMware engineer, interviewed in PythonWatch interviewAbout interviewing.iointerviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.Sign up for a mock interviewWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/questions/intersection-of-linked-list",
          "author": "",
          "user_id": ""
        },
        {
          "title": "How to Solve K Largest Elements",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryLearning CenterQuestionsK Largest ElementsTable of ContentsIntroductionAnalysisSolutionsBrowse all interview replaysLife is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedMEDIUMDATA STRUCTURES AND ALGORITHMSHow to Solve K Largest ElementsARRAYSPRIORITY QUEUESHEAPSWritten ByAdam BhulaK Largest Elements IntroductionThe K Largest Elements problem asks us to print k largest elements in an array, from largest to smallest. We can easily solve this problem by iterating through the array and adding elements to our heap and maintaining the size to be at most K.K Largest Elements ProblemWrite an efficient program for printing k largest elements in an array. Largest elements are returned in order largest to smallest. Example Inputs and Outputs Example 1 Input: nums = \\[3, 7, 2, 1, 8, 5, 9\\], k = 3 Output: \\[9,8,7\\]K Largest Elements SolutionsHeap: To find the k largest elements in the array, we utilize a heap/priority queue data structure. Both the Python and Java solutions follow a similar approach. We iterate through each number in the array and add it to the heap. However, we maintain the size of the heap to be at most k, ensuring that it contains the k largest elements encountered so far. In the Python solution, we use the heapq module to create a min heap. For each number, we push it onto the heap using heapq.heappush. If the size of the heap exceeds k, we remove the smallest element from the heap using heapq.heappop. After iterating through all the numbers, the top k elements in the heap will be the k largest elements in the array. We retrieve them from the heap using heapq.heappop and return them as the result. Priority Queue: Similarly, in the Java solution, we use the PriorityQueue class, which by default implements a min heap. We create a PriorityQueue object called minHeap to store the numbers. For each number in the array, we add it to the minHeap using the offer method. If the size of the minHeap exceeds k, we remove the smallest element from the minHeap using the poll method. Finally, the top k elements in the minHeap will be the k largest elements in the array. We retrieve them from the minHeap by repeatedly calling the poll method and store them in an array called kLargest. Since the PriorityQueue stores elements in ascending order, we populate kLargest in reverse order (from the end to the beginning) to obtain the k largest elements in descending order. We utilize a heap data structure in JavaScript. We maintain a heap array that contains the k largest elements encountered so far. For each number in the input array, we add it to the heap array. If the heap size exceeds k, we sort the heap in descending order and keep only the top k elements. By the end of the iteration, the heap array contains the k largest elements in descending order. We can then return this array as the result.JavaJavaScriptPythonimport java.util.PriorityQueue; public class KthLargestElement { public static int\\[\\] findKLargest(int\\[\\] nums, int k) { PriorityQueue minHeap = new PriorityQueue<>(); for (int num : nums) { minHeap.offer(num); if (minHeap.size() > k) { minHeap.poll(); } } int\\[\\] kLargest = new int\\[k\\]; for (int i = k - 1; i >= 0; i--) { kLargest\\[i\\] = minHeap.poll(); } return kLargest; } public static void main(String\\[\\] args) { int\\[\\] nums = {3, 7, 2, 1, 8, 5, 9}; int k = 3; int\\[\\] result = findKLargest(nums, k); System.out.print(\"The \" + k + \" largest elements in the array are: \"); for (int num : result) { System.out.print(num + \" \"); } } }1import java.util.PriorityQueue; 2 3public class KthLargestElement { 4 public static int\\[\\] findKLargest(int\\[\\] nums, int k) { 5 PriorityQueue minHeap = new PriorityQueue<>(); 6 for (int num : nums) { 7 minHeap.offer(num); 8 if (minHeap.size() > k) { 9 minHeap.poll(); 10 } 11 } 12 13 int\\[\\] kLargest = new int\\[k\\]; 14 for (int i = k - 1; i >= 0; i--) { 15 kLargest\\[i\\] = minHeap.poll(); 16 } 17 return kLargest; 18 } 19 20 public static void main(String\\[\\] args) { 21 int\\[\\] nums = {3, 7, 2, 1, 8, 5, 9}; 22 int k = 3; 23 int\\[\\] result = findKLargest(nums, k); 24 System.out.print(\"The \" + k + \" largest elements in the array are: \"); 25 for (int num : result) { 26 System.out.print(num + \" \"); 27 } 28 } 29}Time/Space Complexity Analysis Time Complexity: O(n log k), where n is the length of the array. Space Complexity: O(k), we use a heap/priority queue to store the k largest elements, so the space required is proportional to the value of k. In the worst case, if k is equal to the length of the array (k = n), the space complexity would be O(n). Watch These Related Mock Interviewsinterviewing.io InterviewerString shuffle and analysisAdequate Lobster, an interviewing.io engineer, interviewed in PythonWatch interviewAbout interviewing.iointerviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.Sign up for a mock interviewWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/questions/k-largest-elements",
          "author": "",
          "user_id": ""
        },
        {
          "title": "How to Solve Simplify Path",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryLearning CenterQuestionsSimplify PathTable of ContentsIntroductionAnalysisSolutionsBrowse all interview replaysLife is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedMEDIUMDATA STRUCTURES AND ALGORITHMSHow to Solve Simplify PathSTACKSSTRINGSPARSINGWritten ByTom WagnerTom has four years of experience developing software professionally, including experience at both Amazon and Pinterest. He is experienced both as an interviewer, conducting interviews on behalf of the companies he's worked for, and interviewee, as he has landed software engineering offers from Google, Twitter, Stripe, Airtable and Doordash during previous job searches.Dominic PlattDominic is a backend software engineer with five years of professional experience. He has worked in various tech industries from IoT to healthcare and has recently secured a position at Amazon. He has a keen interest in data structures and algorithms.Simplify Path IntroductionThe Simplify Path problem involves taking a path as a string and returning the shortest equivalent path by removing redundant elements such as \"..\" and \".\". This problem can be solved using a variety of techniques such as string manipulation, recursion, or using a stack.Simplify Path ProblemYou are given a path to a file as a string. The path can contain the symbols: “..” for the parent directory and “.” for the current directory. Convert the path into its simplified form. Example Inputs and Outputs Example 1 Input: path = \"/home/../etc\" Output: \"/etc\" Example 2 Input: path = \"/home/./me\" Output: \"/home/me\" Example 3 Input: path = \"/home//me/\" Output: \"/home/me\" Constraints The path is absolute, meaning it always starts with \"/\" length(path) > 0 path is composed of alphanumeric, \".\" or \"/\" characters Simplify Path SolutionsThe path we are given is like any file path on your computer. The file path is made up of a series of directories separated by \"/\". In addition to regular directories, there are two other symbols: \".\" which refers to the current directory and \"..\" which refers to the parent directory. By following each step of the path we can find the file. Our goal is to simplify the file path. Meaning we need to return the path in its most direct form. Let's have a look at what simplifying a file path means with a diagram which follows an example of \"/home/../etc/.\" We can break down the path into a series of steps separated by \"/\". Starting at the root directory \"/\": \"home\": go to the home directory \"..\": go up one directory - which brings us back to the root directory \"etc\": go into the etc directory \".\": remain in the current directory The simplified path is the direct path to the file. In this case, it is \"/etc\". Notice how we don't include the \"home\" directory because we navigated out of it. With this in mind we can divide our approach into three steps: Parse the path string into a series of directories; Move directory according to each step; Return the direct path to the final directory we are in. Let's break down each step in turn. Step 1: Parse the path string into a series of directories How can we extract a series of steps from the string? We can see that each directory is separated by a \"/\" or a series of \"/\" characters. Extracting out each directory is then a matter of getting the substring that is in between each \"/\" character. Most modern programming languages provide utility functions to split a string by a delimiter. We need to be mindful that consecutive \"/\" should be considered as a single directory delimiter, and there may or may not be trailing slashes. Step 2: Move directory for each path step For each directory we encounter we need to move our directory. There are three step types that we need to handle. Each of these we can identify according to the value of the directory step. \".\": the current directory, don't change directory \"..\": the parent directory, go up one directory Everything else: a genuine directory, go into the directory of that name How do we record what directory we are currently in? One approach would be to record the current directory as a string. Another option would be to use a stack where each item is a directory. We’ll examine each of these approaches in the solution. Step 3: Return the direct path to the final directory we are in Depending on the format used for tracking the current directory we may need to convert the path before returning it. Approach 1: Directory stack We utilize the \"split\" string utility function which returns an array of substrings split by a \"/\". This allows us to easily convert the path into a series of steps. This has the side effect of generating directories of \"\" when there are consecutive \"/\", however we can filter these out and move on to the next directory. We also use the stack data structure to keep track of our current directory. A stack is a data structure in which items can be added to or removed from the end of the stack in constant time, and in our case the items are directories. For each directory step, we can push when we need to move into a directory and pop when we need to navigate to the parent directory. Let's take the example of \"/home/./me/../you\" and see how we can use a stack to keep track of our current directory. We have been keeping a track of our current directory as a stack. While this is convenient for us as we have been evaluating each step, we need to return the result as a string. To convert our stack to the simplified path we can insert a \"/\" char in between each item in the stack and return the result.PythonJavaScriptclass Solution: def simplifyPath(self, path): # Create the stack where we'll keep track of our current directory pathStack = \\[\\] # 1: Convert the path string into directories for curDir in path.split(\"/\"): # 2: Move directory for each path step if not curDir: # Consecutive \"/\" will result in empty directories - skip these # Alternatively, we could filter out duplicate “/” by iterating over string before splitting it up by “/” pass elif curDir == \".\": # \".\" means don't modify current directory pass elif curDir == \"..\": if pathStack: # Don't pop stack if we're already at the root directory pathStack.pop() else: # A \"genuine\" directory, navigate into it pathStack.append(curDir) # 3: Return the final directory return \"/\" + \"/\".join(pathStack) 1class Solution: 2 def simplifyPath(self, path): 3 # Create the stack where we'll keep track of our current directory 4 pathStack = \\[\\] 5 6 # 1: Convert the path string into directories 7 for curDir in path.split(\"/\"): 8 # 2: Move directory for each path step 9 if not curDir: 10 # Consecutive \"/\" will result in empty directories - skip these 11 # Alternatively, we could filter out duplicate “/” by iterating over string before splitting it up by “/” 12 pass 13 14 elif curDir == \".\": 15 # \".\" means don't modify current directory 16 pass 17 18 elif curDir == \"..\": 19 if pathStack: 20 # Don't pop stack if we're already at the root directory 21 pathStack.pop() 22 23 else: 24 # A \"genuine\" directory, navigate into it 25 pathStack.append(curDir) 26 27 # 3: Return the final directory 28 return \"/\" + \"/\".join(pathStack) 29Time / Space Complexity Time Complexity: O(n), where n is the number of characters in the path. Every character of the string is parsed in this solution. The stack push and pop operations take O(1) time. Space Complexity: O(n), where n is the number of directories in the path. In the worst case, the stack will only be pushed to and so will be of size O(n). This solution also contains the array of directories which will also be of size O(n). Approach 2: Character-by-character parsing As an alternative to using a stack, we can parse the path string character by character. The current directory is also stored directly as a string rather than using a stack. As we parse each character there are two cases. The character is a \"/\" or it isn't. If it isn't a \"/\" then it is part of a directory so we add it to our current directory string. When we encounter a \"/\" it means we are at the end of a directory and so we can evaluate the directory. Like before, the loop may produce empty directory strings so we need to make sure to filter those out. The evaluation of each directory is handled in the same way as the previous method. The main difference is that we store our current directory as a string. When we need to add a directory we can append the string to our path. When we need to go up a directory the solution is not so straightforward. We need to modify the string so that everything from and including the last \"/\" is removed. To do that we can locate the index of the last \"/\" character in the string, we can then slice the string so that everything from that index is removed.PythonJavaScriptclass Solution(object): def simplifyPath(self, path): # Store the current directory as a string simplifiedPath = \"\" curDir = \"\" # Add an ending \"/\" so that we always evaluate the final directory path += \"/\" for ch in path: if ch == \"/\": if not curDir: # Consecutive \"/\" will result in empty directories - skip these pass elif curDir == \".\": # \".\" means don't change directory pass elif curDir == \"..\": if simplifiedPath: # Remove the last dir by locating the last \"/\" char i = simplifiedPath.rfind(\"/\") simplifiedPath = simplifiedPath\\[:i\\] else: # A \"genuine\" directory, navigate into it simplifiedPath += \"/\" + curDir # Reset the directory string curDir = \"\" else: curDir += ch if not simplifiedPath: # Return the root directory if the final path is empty return \"/\" return simplifiedPath 1class Solution(object): 2 def simplifyPath(self, path): 3 # Store the current directory as a string 4 simplifiedPath = \"\" 5 curDir = \"\" 6 7 # Add an ending \"/\" so that we always evaluate the final directory 8 path += \"/\" 9 for ch in path: 10 if ch == \"/\": 11 if not curDir: 12 # Consecutive \"/\" will result in empty directories - skip these 13 pass 14 elif curDir == \".\": 15 # \".\" means don't change directory 16 pass 17 elif curDir == \"..\": 18 if simplifiedPath: 19 # Remove the last dir by locating the last \"/\" char 20 i = simplifiedPath.rfind(\"/\") 21 simplifiedPath = simplifiedPath\\[:i\\] 22 23 else: 24 # A \"genuine\" directory, navigate into it 25 simplifiedPath += \"/\" + curDir 26 27 # Reset the directory string 28 curDir = \"\" 29 30 else: 31 curDir += ch 32 33 if not simplifiedPath: 34 # Return the root directory if the final path is empty 35 return \"/\" 36 37 return simplifiedPath 38Time / Space Complexity Time Complexity: O(n), where n is the number of characters in the path. As in the previous solution, every character of the string is parsed. Within the loop, we are calculating the position of the last “/” character. At first glance, it appears this could make the solution O(n^2). However, each time we do this calculation we are only evaluating the last directory string and then removing that directory from the path. In the worst case we’d only be iterating over the entire path again. This makes the solution not as fast as the previous but in terms of time complexity it is still linear. Space Complexity: O(1). Disregarding the output and input strings all the other variables have constant space. This assumes the length of a directory is much less than the size of the path itself. Approach Comparison While both approaches have linear time complexity, the latter solution is not as fast. This is because going up one directory requires us to reparse the string which is not as fast as popping from the stack. However, the latter solution has constant space complexity because it does not require any extra memory. Verbally noting these tradeoffs in an interview can be a great way to signal your knowledge to the interviewer.Practice the Simplify Path Problem With Our AI InterviewerStart AI InterviewWatch These Related Mock InterviewsAbout interviewing.iointerviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.Sign up for a mock interviewWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/questions/simplify-path",
          "author": "",
          "user_id": ""
        },
        {
          "title": "How to Find the Missing Number in an Array (With Solutions in Python & JavaScript)",
          "content": "We helped write the sequel to \"Cracking the Coding Interview\". Read 9 chapters for free →interviewing.ioOpen menuInterview resourcesFor employersGift mock interviewsBlogFAQLog inGive it a tryLearning CenterQuestionsFind the Missing Number in an ArrayTable of ContentsIntroductionAnalysisSolutionsBrowse all interview replaysLife is chaos and pain. Interview prep doesn't have to be.Get instant access to anonymous mock interviews, salary negotiation, and the world's largest library of interview replays.Get startedMEDIUMDATA STRUCTURES AND ALGORITHMSHow to Find the Missing Number in an Array (With Solutions in Python & JavaScript)SEARCHMAPSARRAYSWritten ByTom WagnerTom has four years of experience developing software professionally, including experience at both Amazon and Pinterest. He is experienced both as an interviewer, conducting interviews on behalf of the companies he's worked for, and interviewee, as he has landed software engineering offers from Google, Twitter, Stripe, Airtable and Doordash during previous job searches.Githire B. WahomeGithire (Brian) is a backend and ML engineer with 7 YoE ranging from startups to major corporations. He has worked on tech serving a wide demographic ranging from mobile money in his homeland Kenya, embedded tech with Kakao in South Korea to MLE at Microsoft. Brian has also worked as a teacher and has a knack for writing technical articlesAn Overview of the Find Missing Number in an Array ProblemThe Find Missing Number in an Array problem involves identifying the missing number between two almost identical arrays. While the task is straightforward, the challenge in this problem is appropriately communicating the time and space complexity tradeoffs offered by data structures with constant time or linear time lookups.Examples of the Find Missing Number in an Array Interview QuestionGiven an unsorted array of unique integers (size n + 1) and a first array identical to the second array, but missing one integer (size n), find and output the missing integer. Input: list1 = \\[1, 2, 3, 4\\] list2 = \\[1, 2, 3, 4, 5\\] Output: 5 Input: \\[1\\], \\[\\] Output: 1 Constraints -inf ≤ n ≤ inf All entries are unique length(list2) - length(list1) == 1 How to Find the Missing Number in an Array: 4 ApproachesLet’s start by reframing this problem as a real world problem. Imagine you're a warehouse supervisor and you have to conduct a roll call every morning. To keep the problem statement analogous to our real-world example, let’s refer to the longer list as the register, which enumerates all the workers who are supposed to show up to the warehouse on a given day. Let’s refer to the smaller list as the actual attendance, denoting who actually showed up. Approach 1: Brute Force In a warehouse, the supervisor typically has a list of all the workers for a given shift. As the workers arrive, they're crossed out on the list, leaving the absentees. To conduct our roll call, we run through the register (or longer list), verifying that we have the integers in the attendance list (the smaller list). If any of the workers are missing, we would have found our absentee, so we return it, or break out of the loop and return the integer at which we stopped iterating. The code for this in Python would be as follows:PythonJavaScriptJavalist1 = \\[1,2,3,4\\] list2 = \\[1,2,3,4,5\\] def find\\_missing\\_number(list1, list2): for integer in list2: # Conduct our roll call against the list2 if integer not in list1: return integer # Break when an absentee is found find\\_missing\\_number(list1, list2) # returns 51list1 = \\[1,2,3,4\\] 2list2 = \\[1,2,3,4,5\\] 3 4def find\\_missing\\_number(list1, list2): 5 for integer in list2: # Conduct our roll call against the list2 6 if integer not in list1: 7 return integer # Break when an absentee is found 8 9find\\_missing\\_number(list1, list2) # returns 5This approach works, but isn't very efficient, as we have to scan the entire attendance list every time we look up a number. Scanning is an O(n) (linear) operation; thus, we have an O(n²) solution (Our example models the worst case as we have to scan both lists exhaustively). The space complexity is O(1) as we only need to keep tracking one integer at a time, the index. Time/Space Complexity Time Complexity: O(n²) Space Complexity: O(1) Can we do better? Of course! Let's think a bit more. What if we didn't have to scan the register each time we wanted to look up a worker? Hash tables / dictionaries and sets to the rescue. Approach 2: Leveraging O(1) Lookups The first approach works, but scanning the attendance list every time isn't optimal. Can we leverage any data structures that optimize for lookups? Both hash maps and sets allow for O(1) lookups. We can optimize for time by converting the smaller list into a set, then searching for every item in the longer list within the set. The tradeoff with this approach is increased efficiency from a time-complexity perspective at the expense of additional memory / space complexity, as we need an auxiliary hash table or set to do the O(1) lookups.PythonJavaScriptJavadef find\\_missing\\_number\\_sets(list1, list2): list1 = set(list1) # ’Setify’ the list for integer in list2: # Conduct our roll call against the list2 if integer not in list1: return integer # Break when an absentee is found print(find\\_missing\\_number\\_sets(list1, list2)) # returns 5 def find\\_missing\\_number\\_dict(list1, list2): list1 = {elem:True for elem in list1} #Turn into a dict for integer in list2: # Conduct our roll call against the list2 if integer not in list1: return integer # Break when an absentee is found print(find\\_missing\\_number\\_dict(list1, list2)) # returns 5 1def find\\_missing\\_number\\_sets(list1, list2): 2 list1 = set(list1) # ’Setify’ the list 3 for integer in list2: # Conduct our roll call against the list2 4 if integer not in list1: 5 return integer # Break when an absentee is found 6 7print(find\\_missing\\_number\\_sets(list1, list2)) # returns 5 8 9def find\\_missing\\_number\\_dict(list1, list2): 10 list1 = {elem:True for elem in list1} #Turn into a dict 11 for integer in list2: # Conduct our roll call against the list2 12 if integer not in list1: 13 return integer # Break when an absentee is found 14 15print(find\\_missing\\_number\\_dict(list1, list2)) # returns 5 16Time/Space Complexity Time Complexity: O(n) Space Complexity: O(n) Due to the constant time lookup, we have now achieved O(n) lookup time but now use O(n) space. It seems like the classic quip, ‘throw a hash-map at it’, actually holds its weight. Is this the best we can do? For time complexity, sadly, yes. But can we optimize for space? Approach 3: Supervisor Keeping Track of Orders Filled Consider the list \\[1, 2, 3, 4, 5\\], which sums to 15. Now consider another list \\[1, 2, 3, 5\\], which sums to 11. Notice anything about these two numbers? The difference between 11 and 15 is 4, which is our answer.PythonJavaScriptJavadef find\\_missing\\_number\\_simple\\_sum(list1, list2): expected\\_sum = 0 for integer in list2: expected\\_sum += integer # Calculate expected total for integer in list1: expected\\_sum -= integer # Subtract filled orders return expected\\_sum # Return pending orders print(find\\_missing\\_number\\_simple\\_sum(list1, list2)) def find\\_missing\\_number\\_sum\\_simultaneous(list1, list2): expected\\_sum = 0 for idx in range(len(list1)): expected\\_sum += list1\\[idx\\] expected\\_sum -= list2\\[idx\\] # Include last entry of the list2 return expected\\_sum + list2\\[-1\\] # Return pending orders print(find\\_missing\\_number\\_sum\\_simultaneous(list1, list2)) 1def find\\_missing\\_number\\_simple\\_sum(list1, list2): 2 expected\\_sum = 0 3 4 for integer in list2: expected\\_sum += integer # Calculate expected total 5 for integer in list1: expected\\_sum -= integer # Subtract filled orders 6 7 return expected\\_sum # Return pending orders 8 9print(find\\_missing\\_number\\_simple\\_sum(list1, list2)) 10 11def find\\_missing\\_number\\_sum\\_simultaneous(list1, list2): 12 expected\\_sum = 0 13 14 for idx in range(len(list1)): 15 expected\\_sum += list1\\[idx\\] 16 expected\\_sum -= list2\\[idx\\] 17 18 # Include last entry of the list2 19 return expected\\_sum + list2\\[-1\\] # Return pending orders 20 21print(find\\_missing\\_number\\_sum\\_simultaneous(list1, list2)) 22Time/Space Complexity Time Complexity: O(n) Space Complexity: O(1) for most cases, but technically O(n). On the surface this seems like an O(1) space complexity solution, however if the sum of the numbers exceeds the 32-bit or 64-bit integer memory limit the space complexity will actually be O(n). This is why we see the Big Int / Big Integer construct in certain languages. Approach 4\\[Advanced Technique\\]: Bit Manipulation Please note that this is an advanced technique that is not expected to be known for most programming interviews, so if you are studying for an entry-level, mid-level or Senior position this content is likely overkill relative to what you need to know. All integers can be represented as 0s and 1s. With just 2 bits, 0 is equivalent to 00, 1 is equal to 1, and 3 is 11. There are only 10 types of people in the world, those who understand binary and those who do not. Ensure you do before proceeding to the next section :) XOR XOR stands for 'exclusive OR'. Simply put, it is an OR operation without the possibility of equality. True OR True would be True, but True XOR True would be False. How does this help us? Integers typically are represented using 32 bits, at least in Python. The number 1 as base 2 is: \"00000000000000000000000000000001\" The number 10 would be equivalent to the following: \"00000000000000000000000000001010\" So long as an entry is an integer, we only need 32 bits to keep track of it. If we start with a clean slate, i.e., the value 0, we would have the following: \"00000000000000000000000000000000\" Now, what if we did a bitwise XOR between 0 and 1? “00000000000000000000000000000000” XOR “00000000000000000000000000000001” Each positionally equivalent bit will be compared, and we will end up with a 1: “00000000000000000000000000000001” Converting this back to base 10 returns 1. Now let us ask ourselves, what if we did an XOR of 1 and 1? We would return 0 for that first bit, thus reverting to a clean slate again. “00000000000000000000000000000001” XOR “00000000000000000000000000000001” = “00000000000000000000000000000000” You can play around with bitwise operations here: https://unsuitable001.github.io/BitViz/ Now how is this useful for our problem? For each integer both in the attendance list and the registry, so long as an XOR operation is performed, equal integers will cancel out their corresponding bit flips and restore the clean slate of the result, all but 1. The absentee integer in the registry will perform bit flips that will not be canceled out. As a result, once we are done with the XOR operations over all entries, the only 1 bits standing will represent the absent number once we are done. In Python and JavaScript, ^ is used to perform the bitwise XOR operation. As such, you can do 1 ^ 1, which should return 0.PythonJavaScriptprint(1 ^ 1) # 01print(1 ^ 1) # 0Building on this logic, we can start with a 0 as our slate and XOR all integers in both lists against the slate. Upon iterating through all elements, we will be left with our absent integer:PythonJavaScriptJavadef find\\_missing\\_number\\_simple\\_bitwise(list1, list2): slate = 0 for integer in list2: slate ^= integer # XOR integers against slate for integer in list1: slate ^= integer return slate # Whatever we are left with is the missing int print(find\\_missing\\_number\\_simple\\_bitwise(list1, list2)) def find\\_missing\\_number\\_bitwise\\_simultaneous(list1, list2): slate = 0 for idx in range(len(list1)): slate ^= list1\\[idx\\] # XOR against slate simultaneously slate ^= list2\\[idx\\] # Include last entry of list2 return slate ^ list2\\[-1\\] # Return pending integers print(find\\_missing\\_number\\_bitwise\\_simultaneous(list1, list2)) 1def find\\_missing\\_number\\_simple\\_bitwise(list1, list2): 2 slate = 0 3 4 for integer in list2: slate ^= integer # XOR integers against slate 5 for integer in list1: slate ^= integer 6 7 return slate # Whatever we are left with is the missing int 8 9print(find\\_missing\\_number\\_simple\\_bitwise(list1, list2)) 10 11def find\\_missing\\_number\\_bitwise\\_simultaneous(list1, list2): 12 slate = 0 13 14 for idx in range(len(list1)): 15 slate ^= list1\\[idx\\] # XOR against slate simultaneously 16 slate ^= list2\\[idx\\] 17 18 # Include last entry of list2 19 return slate ^ list2\\[-1\\] # Return pending integers 20print(find\\_missing\\_number\\_bitwise\\_simultaneous(list1, list2)) 21And there we have it, a clean approach that uses a constant number of bits and thus is precisely constant space. Time/Space Complexity Time Complexity: O(1) Space Complexity: O(1), as we will only ever need 32 bits for so long as all our entries are integers. Practice the Find the Missing Number in an Array Problem With Our AI InterviewerStart AI InterviewWatch These Related Mock InterviewsAirbnb InterviewerMissing item list differenceThe Legendary Artichoke, an Airbnb engineer, interviewed in PythonWatch interviewAbout interviewing.iointerviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.Sign up for a mock interviewWe know exactly what to do and say to get the company, title, and salary you want.Interview prep and job hunting are chaos and pain. We can help. Really.Get started for freeinterviewing.ioInterview ReplaysSystem design mock interviewGoogle mock interviewJava mock interviewPython mock interviewMicrosoft mock interviewInterview Questions by Language/CompanyJava interview questionsPython interview questionsJavaScript interview questionsAmazon interview questionsGoogle interview questionsMeta interview questionsApple interview questionsNetflix interview questionsMicrosoft interview questionsPopular Interview QuestionsReverse stringLongest substring without repeating charactersLongest common subsequenceContainer with most waterReverse linked listK closest points to originKth smallest elementReverse words in a stringGuidesAmazon Leadership PrinciplesSystem Design Interview GuideFAANG Hiring Process GuideCompanyFor engineersFor employersBlogPressFAQSecurityLog in©2025 Interviewing.io Inc. Made with <3 in San Francisco.Privacy PolicyTerms of Service",
          "content_type": "other",
          "source_url": "https://interviewing.io/questions/find-missing-number-in-array",
          "author": "",
          "user_id": ""
        }
      ]
    }
  ]
}